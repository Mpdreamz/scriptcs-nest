<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nest</name>
    </assembly>
    <members>
        <member name="M:Nest.IElasticClient.Serialize(System.Object)">
            <summary>
            serialize an object using the internal registered converters without camelcasing properties as is done 
            while indexing objects
            </summary>
        </member>
        <member name="M:Nest.IElasticClient.SerializeCamelCase(System.Object)">
            <summary>
            Serialize an object using the default camelCasing used while indexing objects
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteById``1(System.Int32)">
            <summary>
            Synchronously deletes a document by id in the default index and the inferred typename for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteById``1(System.String)">
            <summary>
            Synchronously deletes a document by id in the default index and the inferred typename for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteById(System.String,System.String,System.String)">
            <summary>
            Synchronously deletes a document by id in the specified index and type
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteById(System.String,System.String,System.Int32)">
            <summary>
            Synchronously deletes a document by id in the specified index and type
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteById``1(System.Int32,Nest.DeleteParameters)">
            <summary>
            Synchronously deletes a document by id in the default index and the inferred typename for T
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>
        </member>
        <member name="M:Nest.ElasticClient.DeleteById``1(System.String,Nest.DeleteParameters)">
            <summary>
            Synchronously deletes a document by id in the default index and the inferred typename for T
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>
        </member>
        <member name="M:Nest.ElasticClient.DeleteById(System.String,System.String,System.String,Nest.DeleteParameters)">
            <summary>
            Synchronously deletes a document by id in the specified index and type
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>
        </member>
        <member name="M:Nest.ElasticClient.DeleteById(System.String,System.String,System.Int32,Nest.DeleteParameters)">
            <summary>
            Synchronously deletes a document by id in the specified index and type
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>
        </member>
        <member name="M:Nest.ElasticClient.DeleteByIdAsync``1(System.Int32)">
            <summary>
            Asynchronously deletes a document by id in the default index and the inferred typename for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteByIdAsync``1(System.String)">
            <summary>
            Asynchronously deletes a document by id in the default index and the inferred typename for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteByIdAsync(System.String,System.String,System.String)">
            <summary>
            Asynchronously deletes a document by id in the specified index and type
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteByIdAsync(System.String,System.String,System.Int32)">
            <summary>
            Asynchronously deletes a document by id in the specified index and type
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteByIdAsync``1(System.Int32,Nest.DeleteParameters)">
            <summary>
            Asynchronously deletes a document by id in the default index and the inferred typename for T
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>
        </member>
        <member name="M:Nest.ElasticClient.DeleteByIdAsync``1(System.String,Nest.DeleteParameters)">
            <summary>
            Asynchronously deletes a document by id in the default index and the inferred typename for T
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>
        </member>
        <member name="M:Nest.ElasticClient.DeleteByIdAsync(System.String,System.String,System.String,Nest.DeleteParameters)">
            <summary>
            Asynchronously deletes a document by id in the specified index and type
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>
        </member>
        <member name="M:Nest.ElasticClient.DeleteByIdAsync(System.String,System.String,System.Int32,Nest.DeleteParameters)">
            <summary>
            Asynchronously deletes a document by id in the specified index and type
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>
        </member>
        <member name="M:Nest.ElasticClient.DeleteByQuery``1(System.Action{Nest.RoutingQueryPathDescriptor{``0}},Nest.DeleteByQueryParameters)">
            <summary>
            Deletes all documents that match the query
            </summary>
            <param name="query">RoutingQueryPathDescriptor also allows you to control which indices and types are affected</param>
            <param name="parameters">Control routing/consistency and replication</param>
            <returns>IDeleteResponse, check .IsValid to validate success</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteByQuery(System.Action{Nest.RoutingQueryPathDescriptor},Nest.DeleteByQueryParameters)" -->
        <member name="M:Nest.ElasticClient.DeleteByQueryRaw(System.String,Nest.DeleteByQueryParameters)">
            <summary>
            Deletes all documents that match the string query.
            </summary>
            <param name="query">RoutingQueryPathDescriptor also allows you to control which indices and types are affected</param>
            <param name="parameters">Control routing/consistency and replication</param>
            <returns>IDeleteResponse, check .IsValid to validate success</returns>
        </member>
        <member name="M:Nest.ElasticClient.DeleteByQueryAsync``1(System.Action{Nest.RoutingQueryPathDescriptor{``0}},Nest.DeleteByQueryParameters)">
            <summary>
            Deletes all documents that match the query
            </summary>
            <param name="query">RoutingQueryPathDescriptor also allows you to control which indices and types are affected</param>
            <param name="parameters">Control routing/consistency and replication</param>
            <returns>IDeleteResponse, check .IsValid to validate success</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteByQueryAsync(System.Action{Nest.RoutingQueryPathDescriptor},Nest.DeleteByQueryParameters)" -->
        <member name="M:Nest.ElasticClient.DeleteByQueryRawAsync(System.String,Nest.DeleteByQueryParameters)">
            <summary>
            Deletes all documents that match the string query.
            </summary>
            <param name="query">RoutingQueryPathDescriptor also allows you to control which indices and types are affected</param>
            <param name="parameters">Control routing/consistency and replication</param>
            <returns>IDeleteResponse, check .IsValid to validate success</returns>
        </member>
        <member name="M:Nest.ElasticClient.DeleteMany``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Deletes all the objects by inferring its id in the default index and the inferred type for T
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteMany``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}})" -->
        <member name="M:Nest.ElasticClient.DeleteMany``1(System.Collections.Generic.IEnumerable{``0},Nest.SimpleBulkParameters)">
            <summary>
            Deletes all the objects by inferring its id in the default index and the inferred type for T
            </summary>
            <param name="bulkParameters">allows you to control the replication and refresh behavior</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteMany``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},Nest.SimpleBulkParameters)" -->
        <member name="M:Nest.ElasticClient.DeleteMany``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Deletes all the objects by inferring its id in the specified index and the inferred type for T
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteMany``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String)" -->
        <member name="M:Nest.ElasticClient.DeleteMany``1(System.Collections.Generic.IEnumerable{``0},System.String,Nest.SimpleBulkParameters)">
            <summary>
            Deletes all the objects by inferring its id in the specified index and the inferred type for T
            </summary>
            <param name="bulkParameters">allows you to control the replication and refresh behavior</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteMany``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String,Nest.SimpleBulkParameters)" -->
        <member name="M:Nest.ElasticClient.DeleteMany``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>
            Deletes all the objects by inferring its id in the specified index and type
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteMany``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String,System.String)" -->
        <member name="M:Nest.ElasticClient.DeleteMany``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,Nest.SimpleBulkParameters)">
            <summary>
            Deletes all the objects by inferring its id in the specified index and type
            </summary>
            <param name="bulkParameters">allows you to control the replication and refresh behavior</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteMany``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String,System.String,Nest.SimpleBulkParameters)" -->
        <member name="M:Nest.ElasticClient.DeleteManyAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Deletes all the objects by inferring its id in the default index and the inferred type for T
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteManyAsync``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}})" -->
        <member name="M:Nest.ElasticClient.DeleteManyAsync``1(System.Collections.Generic.IEnumerable{``0},Nest.SimpleBulkParameters)">
            <summary>
            Deletes all the objects by inferring its id in the default index and the inferred type for T
            </summary>
            <param name="bulkParameters">allows you to control the replication and refresh behavior</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteManyAsync``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},Nest.SimpleBulkParameters)" -->
        <member name="M:Nest.ElasticClient.DeleteManyAsync``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Deletes all the objects by inferring its id in the specified index and the inferred type for T
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteManyAsync``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String)" -->
        <member name="M:Nest.ElasticClient.DeleteManyAsync``1(System.Collections.Generic.IEnumerable{``0},System.String,Nest.SimpleBulkParameters)">
            <summary>
            Deletes all the objects by inferring its id in the specified index and the inferred type for T
            </summary>
            <param name="bulkParameters">allows you to control the replication and refresh behavior</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteManyAsync``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String,Nest.SimpleBulkParameters)" -->
        <member name="M:Nest.ElasticClient.DeleteManyAsync``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>
            Deletes all the objects by inferring its id in the specified index and type
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteManyAsync``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String,System.String)" -->
        <member name="M:Nest.ElasticClient.DeleteManyAsync``1(System.Collections.Generic.IEnumerable{``0},System.String,Nest.SimpleBulkParameters,System.String)">
            <summary>
            Deletes all the objects by inferring its id in the specified index and type
            </summary>
            <param name="bulkParameters">allows you to control the replication and refresh behavior</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteManyAsync``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String,Nest.SimpleBulkParameters,System.String)" -->
        <member name="M:Nest.ElasticClient.CreateIndex(System.String,Nest.IndexSettings)">
            <summary>
            Create an index with the specified index settings
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.CreateIndex(System.String,System.Func{Nest.CreateIndexDescriptor,Nest.CreateIndexDescriptor})">
            <summary>
            Create an index with the specified index settings
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Health(Nest.HealthLevel)">
            <summary>
            Gets the health status of the cluster, at the specified level.
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.ElasticClient.Health(System.Collections.Generic.IEnumerable{System.String},Nest.HealthLevel)">
            <summary>
            Gets the health status of the cluster, at the specified level, for the specified indexes.
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.ElasticClient.Health(Nest.HealthParams)">
            <summary>
            Gets the health status of the cluster according to the healthparams passed.
            </summary>
            <param name="healthParams"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.ElasticClient.Health(System.Collections.Generic.IEnumerable{System.String},Nest.HealthParams)">
            <summary>
            Gets the health status of the cluster according to the healthparams passed, for the specified indexes.
            </summary>
            <param name="healthParams"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.ElasticClient.MoreLikeThis``1(System.Func{Nest.MoreLikeThisDescriptor{``0},Nest.MoreLikeThisDescriptor{``0}})">
            <summary>
            Search using T as the return type
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.GetMapping``1">
            <summary>
            Get the current mapping for T at the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.GetMapping``1(System.String)">
            <summary>
            Get the current mapping for T at the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.GetMapping(System.Type)">
            <summary>
            Get the current mapping for T at the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.GetMapping(System.Type,System.String)">
            <summary>
            Get the current mapping for T at the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.GetMapping(System.String,System.String)">
            <summary>
            Get the current mapping for type at the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteMapping``1">
            <summary>
            Deletes the mapping for the inferred type name of T under the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteMapping``1(System.String)">
            <summary>
            Deletes the mapping for the inferred type name of T under the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteMapping``1(System.String,System.String)">
            <summary>
            Deletes the mapping for the specified type name under the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteMapping(System.Type)">
            <summary>
            Deletes the mapping for the inferred type name of T under the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteMapping(System.Type,System.String)">
            <summary>
            Deletes the mapping for the inferred type name of T under the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteMapping(System.Type,System.String,System.String)">
            <summary>
            Deletes the mapping for the specified type name under the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.GetFull``1(System.Int32)">
            <summary>
            Gets a document of T by id in the default index and the inferred typename for T
            </summary>
            <returns>an instance of T</returns>
        </member>
        <member name="M:Nest.ElasticClient.GetFull``1(System.String)">
            <summary>
            Gets a document of T by id in the default index and the inferred typename for T
            </summary>
            <returns>an instance of T</returns>
        </member>
        <member name="M:Nest.ElasticClient.GetFull``1(System.String,System.String,System.String)">
            <summary>
            Gets a document of T by id in the specified index and the specified typename
            </summary>
            <returns>an instance of T</returns>
        </member>
        <member name="M:Nest.ElasticClient.GetFull``1(System.String,System.String,System.Int32)">
            <summary>
            Gets a document of T by id in the specified index and the specified typename
            </summary>
            <returns>an instance of T</returns>
        </member>
        <member name="M:Nest.ElasticClient.MultiGet``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets multiple documents of T by id in the default index and the inferred typename for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.MultiGet``1(System.String,System.String,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Gets multiple documents of T by id in the specified index and the specified typename for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.MultiGet``1(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets multiple documents of T by id in the specified index and the specified typename for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.NodeInfo(Nest.NodesInfo)">
            <summary>
            Gets the health status of the cluster.
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.NodeInfo(System.Collections.Generic.IEnumerable{System.String},Nest.NodesInfo)">
            <summary>
            Gets the health status of the cluster, for the specified nodes.
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.NodeStats(Nest.NodeInfoStats)">
            <summary>
            Gets the health status of each node in the cluster, for the specified indexes.
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.NodeStats(System.Collections.Generic.IEnumerable{System.String},Nest.NodeInfoStats)">
            <summary>
            Gets the health status of each node in the cluster, for the specified indexes.
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Scroll(System.String,System.String)">
            <summary>
            Scrolling search, ideal for scrolling on the server as it allows to keep a query open on the serverside.
            Please consult the docs http://www.elasticsearch.org/guide/reference/api/search/scroll.html
            on the do's and don'ts!
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.ValidateRaw(System.String)">
            <summary>
            The validate API allows a user to validate a potentially expensive query without executing it. 
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Validate(System.Action{Nest.ValidateQueryPathDescriptor})">
            <summary>
            The validate API allows a user to validate a potentially expensive query without executing it. 
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Validate``1(System.Action{Nest.ValidateQueryPathDescriptor{``0}})">
            <summary>
            The validate API allows a user to validate a potentially expensive query without executing it. 
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Serialize(System.Object)">
            <summary>
            serialize an object using the internal registered converters without camelcasing properties as is done 
            while indexing objects
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.SerializeCamelCase(System.Object)">
            <summary>
            Serialize an object using the default camelCasing used while indexing objects
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Deserialize``1(System.String,System.Collections.Generic.IEnumerable{Newtonsoft.Json.JsonConverter})">
            <summary>
            Deserialize an object 
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.RegisterPercolator(System.String,System.Action{Nest.QueryPathDescriptor{System.Object}})">
            <summary>
            Register a percolator
            </summary>
            <param name="name">Name of the percolator</param>
            <param name="querySelector">Path and query descriptor using dynamics to describe the query</param>
        </member>
        <member name="M:Nest.ElasticClient.RegisterPercolator``1(System.String,System.Action{Nest.QueryPathDescriptor{``0}})">
            <summary>
            Register a percolator
            </summary>
            <param name="name">Name of the percolator</param>
            <param name="querySelector">Path and query descriptor using T to describe the query</param>
        </member>
        <member name="M:Nest.ElasticClient.UnregisterPercolator``1(System.String)">
            <summary>
            Unregister a percolator, on the default index.
            </summary>
            <param name="name">Name of the percolator</param>
        </member>
        <member name="M:Nest.ElasticClient.UnregisterPercolator(System.String,System.String)">
            <summary>
            Unregister a percolator
            </summary>
            <param name="name">Name of the percolator</param>
        </member>
        <member name="M:Nest.ElasticClient.Percolate``1(``0)">
            <summary>
            Manually percolate an object using its inferred typename and the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Percolate``1(System.String,``0)">
            <summary>
            Manually percolate an object using its inferred typename and the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Percolate``1(System.String,System.String,``0)">
            <summary>
            Manually percolate an object using the specified typename and the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Segments">
            <summary>
            Get segment information for all the indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Segments(System.String)">
            <summary>
            Get the segment information for the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Segments(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Get the segment information for the specified indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexExists(System.String)">
            <summary>
            Check if the index already exists
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Stats">
            <summary>
            Gets all the stats for all the indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Stats(Nest.StatsParams)">
            <summary>
            Gets only the specified stats for all the indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Stats(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets all the stats for the specified indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Stats(System.String)">
            <summary>
            Gets all the stats for the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Stats(System.Collections.Generic.IEnumerable{System.String},Nest.StatsParams)">
            <summary>
            Gets the specified stats for the specified indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.GetIndexSettings">
            <summary>
            Gets the index settings for the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.GetIndexSettings(System.String)">
            <summary>
            Gets the index settings for the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.UpdateSettings(Nest.IndexSettings)">
            <summary>
            Update the index settings for the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.UpdateSettings(System.String,Nest.IndexSettings)">
            <summary>
            Update the index settings for the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteIndex``1">
            <summary>
            Delete the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteIndex(System.String)">
            <summary>
            Delete the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.ClearCache">
            <summary>
            Clears all caches of all indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.ClearCache``1">
            <summary>
            Clears the entire cache for the default index set in the client settings
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.ClearCache``1(Nest.ClearCacheOptions)">
            <summary>
            Clears the specified caches for the default index set in the client settings
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.ClearCache(Nest.ClearCacheOptions)">
            <summary>
            Clears the specified caches for all indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.ClearCache(System.Collections.Generic.IEnumerable{System.String},Nest.ClearCacheOptions)">
            <summary>
            Clears the specified caches for only the indices passed under indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Analyze(System.String)">
            <summary>
            Performs the standard analysis process on a text and return the tokens breakdown of the text.
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.ElasticClient.Analyze(Nest.AnalyzeParams,System.String)">
            <summary>
            Analyzes specified text according to the analyzeparams passed.
            </summary>
            <returns>AnalyzeResponse contains a breakdown of the token under .Tokens</returns>
        </member>
        <member name="M:Nest.ElasticClient.Analyze``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Analyzes text according to the current analyzer of the field in the default index set in the clientsettings.
            </summary>
            <returns>AnalyzeResponse contains a breakdown of the token under .Tokens</returns>
        </member>
        <member name="M:Nest.ElasticClient.Analyze``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String,System.String)">
            <summary>
             Analyzes text according to the current analyzer of the field in the passed index.
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.GetIndicesPointingToAlias(System.String)">
            <summary>
            Get all the indices pointing to an alias
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Swap(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Repoint an alias from a set of old indices to a set of new indices in one operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Swap(Nest.AliasParams,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Repoint an alias from a set of old indices to a set of new indices in one operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Alias(System.String)">
            <summary>
            Add an alias to the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Alias(System.String,System.String)">
            <summary>
            Add an alias to the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Alias(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Add multiple aliases to the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Alias(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Add multiple aliases to the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.RemoveAlias(System.String)">
            <summary>
            Remove an alias for the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.RemoveAlias(System.String,System.String)">
            <summary>
            Remove an alias for the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.RemoveAlias(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Remove multiple alias for the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.RemoveAlias(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Remove multiple alias for the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Alias(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Associate multiple indices with one alias
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Rename(System.String,System.String,System.String)">
            <summary>
            Rename an old alias for index to a new alias in one operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Alias(Nest.AliasParams)">
            <summary>
            Freeform alias overload for complete control of all the aspects (does an add operation)
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Alias(System.Collections.Generic.IEnumerable{Nest.AliasParams})">
            <summary>
            Freeform multi alias overload for complete control of all the aspects (does multiple add operations)
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.RemoveAlias(Nest.AliasParams)">
            <summary>
            Freeform remove alias overload for complete control of all the aspects
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.RemoveAliases(System.Collections.Generic.IEnumerable{Nest.AliasParams})">
            <summary>
            Freeform remove multi alias overload for complete control of all the aspects
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Optimize``1">
            <summary>
            Optimize the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Optimize``1(Nest.OptimizeParams)">
            <summary>
            Optimize the default index using the specified optimize params
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Optimize(System.String)">
            <summary>
            Optimize the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Optimize(System.String,Nest.OptimizeParams)">
            <summary>
            Optimize the specified index using the specified optimize params
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Optimize">
            <summary>
            Optimize all indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Optimize(Nest.OptimizeParams)">
            <summary>
            Optimize all indices using the specified optimize params
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Optimize(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Optimize the specified indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Optimize(System.Collections.Generic.IEnumerable{System.String},Nest.OptimizeParams)">
            <summary>
            Optimize the specified indices using the specified optimize params
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Snapshot">
            <summary>
            Snapshot all indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Snapshot``1">
            <summary>
            Snapshot the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Snapshot(System.String)">
            <summary>
            Snapshot the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Snapshot(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Snapshot the specified indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Flush``1(System.Boolean)">
            <summary>
            <para>Flushes the infered typename for T under the default index </para>
            <para>The flush process of an index basically frees memory from the index by flushing data to the index storage and clearing the internal transaction log. By default, ElasticSearch uses memory heuristics in order to automatically trigger flush operations as required in order to clear memory.</para>
            </summary>
            <param name="refresh">optional, wait for the flush operation to complete</param>
        </member>
        <member name="M:Nest.ElasticClient.Flush(System.Boolean)">
            <summary>
            <para>Flushes all indices</para>
            <para>The flush process of an index basically frees memory from the index by flushing data to the index storage and clearing the internal transaction log. By default, ElasticSearch uses memory heuristics in order to automatically trigger flush operations as required in order to clear memory.</para>
            </summary>
            <param name="refresh">optional, wait for the flush operation to complete</param>
        </member>
        <member name="M:Nest.ElasticClient.Flush(System.String,System.Boolean)">
            <summary>
            <para>Flushes the specified index</para>
            <para>The flush process of an index basically frees memory from the index by flushing data to the index storage and clearing the internal transaction log. By default, ElasticSearch uses memory heuristics in order to automatically trigger flush operations as required in order to clear memory.</para>
            </summary>
            <param name="refresh">optional, wait for the flush operation to complete</param>
        </member>
        <member name="M:Nest.ElasticClient.Flush(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            <para>Flushes the specified indices</para>
            <para>The flush process of an index basically frees memory from the index by flushing data to the index storage and clearing the internal transaction log. By default, ElasticSearch uses memory heuristics in order to automatically trigger flush operations as required in order to clear memory.</para>
            </summary>
            <param name="refresh">optional, wait for the flush operation to complete</param>
        </member>
        <member name="M:Nest.ElasticClient.OpenIndex(System.String)">
            <summary>
            Open index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.CloseIndex(System.String)">
            <summary>
            Close index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.OpenIndex``1">
            <summary>
            Open the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.CloseIndex``1">
            <summary>
            Close the default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Refresh">
            <summary>
             refreshes all
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.ElasticClient.Refresh(System.String)">
            <summary>
            Refresh an index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Refresh(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Refresh multiple indices at once.
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Refresh``1">
            <summary>
            refresh the connection settings default index for type T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.CountAllRaw(System.String)">
            <summary>
            Performs a count query over all indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.CountAll(System.Func{Nest.QueryDescriptor,Nest.BaseQuery})">
            <summary>
            Performs a count query over all indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.CountAll``1(System.Func{Nest.QueryDescriptor{``0},Nest.BaseQuery})">
            <summary>
            Performs a count query over all indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.CountRaw(System.String)">
            <summary>
            Performs a count query over the default index set in the client settings
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Count(System.Func{Nest.QueryDescriptor,Nest.BaseQuery})">
            <summary>
            Performs a count query over the default index set in the client settings
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Count(System.Collections.Generic.IEnumerable{System.String},System.Func{Nest.QueryDescriptor,Nest.BaseQuery})">
            <summary>
            Performs a count query over the passed indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Count(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Func{Nest.QueryDescriptor,Nest.BaseQuery})">
            <summary>
            Performs a count query over the multiple types in multiple indices.
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.CountRaw``1(System.String)">
            <summary>
            Perform a count query over the default index and the inferred type name for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Count``1(System.Func{Nest.QueryDescriptor{``0},Nest.BaseQuery})">
            <summary>
            Perform a count query over the default index and the inferred type name for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Count``1(System.Collections.Generic.IEnumerable{System.String},System.Func{Nest.QueryDescriptor{``0},Nest.BaseQuery})">
            <summary>
            Performs a count query over the specified indices
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Count``1(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Func{Nest.QueryDescriptor{``0},Nest.BaseQuery})">
            <summary>
             Performs a count query over the multiple types in multiple indices.
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Delete``1(``0)">
            <summary>
            Synchronously delete the object in the inferred type for T in the default index specified in the client settings
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Delete``1(``0,System.String)">
            <summary>
            Synchronously delete the object in the inferred type for T in specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Delete``1(``0,System.String,System.String)">
            <summary>
            Synchronously delete the object in specified type in the specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Delete``1(``0,Nest.DeleteParameters)">
            <summary>
            Synchronously delete the object in the inferred type for T in the default index specified in the client settings
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>	
        </member>
        <member name="M:Nest.ElasticClient.Delete``1(``0,System.String,Nest.DeleteParameters)">
            <summary>
            Synchronously delete the object in the inferred type for T in the specified index.
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>
        </member>
        <member name="M:Nest.ElasticClient.Delete``1(``0,System.String,System.String,Nest.DeleteParameters)">
            <summary>
            Synchronously delete the object in the inferred type for T in the specified index.
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>
        </member>
        <member name="M:Nest.ElasticClient.DeleteAsync``1(``0)">
            <summary>
            Asynchronously delete the object in the inferred type for T in the default index specified in the client settings
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteAsync``1(``0,System.String)">
            <summary>
            Asynchronously delete the object in the inferred type for T in specified index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.DeleteAsync``1(``0,System.String,System.String)">
            <summary>
            Asynchronously delete the object in specified type in the specified index
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.ElasticClient.DeleteAsync``1(``0,Nest.DeleteParameters)" -->
        <member name="M:Nest.ElasticClient.DeleteAsync``1(``0,System.String,Nest.DeleteParameters)">
            <summary>
            Asynchronously delete the object in the inferred type for T in the specified index.
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>
        </member>
        <member name="M:Nest.ElasticClient.DeleteAsync``1(``0,System.String,System.String,Nest.DeleteParameters)">
            <summary>
            Asynchronously delete the object in the inferred type for T in the specified index.
            </summary>
            <param name="deleteParameters">Allows you to pass in additional delete parameters such as version and routing</param>
        </member>
        <member name="M:Nest.ElasticClient.MapFromAttributes``1(System.Int32)">
            <summary>
            <para>Automatically map an object based on its attributes, this will also explicitly map strings to strings, datetimes to dates etc even 
            if they are not marked with any attributes.</para>
            <para>
            Type name is the inferred type name for T under the default index
            </para>
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.MapFromAttributes``1(System.String,System.Int32)">
            <summary>
            <para>Automatically map an object based on its attributes, this will also explicitly map strings to strings, datetimes to dates etc even 
            if they are not marked with any attributes.</para>
            <para>
            Type name is the inferred type name for T under the specified index
            </para>
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.MapFromAttributes``1(System.String,System.String,System.Int32)">
            <summary>
            <para>Automatically map an object based on its attributes, this will also explicitly map strings to strings, datetimes to dates etc even 
            if they are not marked with any attributes.</para>
            <para>
            Type name is the specified type name under the specified index
            </para>
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.MapFromAttributes(System.Type,System.Int32)">
            <summary>
            <para>Automatically map an object based on its attributes, this will also explicitly map strings to strings, datetimes to dates etc even 
            if they are not marked with any attributes.</para>
            <para>
            Type name is the inferred type name for T under the default index
            </para>
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.MapFromAttributes(System.Type,System.String,System.Int32)">
            <summary>
            <para>Automatically map an object based on its attributes, this will also explicitly map strings to strings, datetimes to dates etc even 
            if they are not marked with any attributes.</para>
            <para>
            Type name is the inferred type name for T under the specified index
            </para>
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.MapFromAttributes(System.Type,System.String,System.String,System.Int32)">
            <summary>
            <para>Automatically map an object based on its attributes, this will also explicitly map strings to strings, datetimes to dates etc even 
            if they are not marked with any attributes.</para>
            <para>
            Type name is the specified type name under the specified index
            </para>
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Map(Nest.RootObjectMapping)">
            <summary>
            Verbosely and explicitly map an object using a TypeMapping object, this gives you exact control over the mapping. Index is the inferred default index
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Map(Nest.RootObjectMapping,System.String,System.String,System.Boolean)">
            <summary>
            Verbosely and explicitly map an object using a TypeMapping object, this gives you exact control over the mapping.
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.MapRaw(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Explicitly map an object using direct json input, the json should be of the form { "type" = {mapping} }.
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Get``1(System.Int32)">
            <summary>
            Gets a document of T by id in the default index and the inferred typename for T
            </summary>
            <returns>an instance of T</returns>
        </member>
        <member name="M:Nest.ElasticClient.Get``1(System.String)">
            <summary>
            Gets a document of T by id in the default index and the inferred typename for T
            </summary>
            <returns>an instance of T</returns>
        </member>
        <member name="M:Nest.ElasticClient.Get``1(System.String,System.String,System.String)">
            <summary>
            Gets a document of T by id in the specified index and the specified typename
            </summary>
            <returns>an instance of T</returns>
        </member>
        <member name="M:Nest.ElasticClient.Get``1(System.String,System.String,System.Int32)">
            <summary>
            Gets a document of T by id in the specified index and the specified typename
            </summary>
            <returns>an instance of T</returns>
        </member>
        <member name="M:Nest.ElasticClient.Index``1(``0)">
            <summary>
            Index object to the default index and the inferred type name for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Index``1(``0,Nest.IndexParameters)">
            <summary>
            Index object to the default index and the inferred type name for T, using index parameters to further control the operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Index``1(``0,System.String)">
            <summary>
            Index object to the specified index and the inferred type name for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Index``1(``0,System.String,Nest.IndexParameters)">
            <summary>
            Index object to the specified index and the inferred type name for T, using index parameters to further control the operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Index``1(``0,System.String,System.String)">
            <summary>
            Index object to the specified index and the specified type name
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Index``1(``0,System.String,System.String,Nest.IndexParameters)">
            <summary>
            Index object to the specified index and the specified type name, using index parameters to further control the operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Index``1(``0,System.String,System.String,System.String)">
            <summary>
            Index object to the specified index and the specified type name and force the id of the object to update
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Index``1(``0,System.String,System.String,System.String,Nest.IndexParameters)">
            <summary>
            Index object to the specified index and the specified type name and force the id of the object to update, using index parameters to further control the operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Index``1(``0,System.String,System.String,System.Int32)">
            <summary>
            Index object to the specified index and the specified type name and force the id of the object to update
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Index``1(``0,System.String,System.String,System.Int32,Nest.IndexParameters)">
            <summary>
            Index object to the specified index and the specified type name and force the id of the object to update, using index parameters to further control the operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexAsync``1(``0)">
            <summary>
            Index object to the default index and the inferred type name for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexAsync``1(``0,Nest.IndexParameters)">
            <summary>
            Index object to the default index and the inferred type name for T, using index parameters to further control the operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexAsync``1(``0,System.String)">
            <summary>
            Index object to the specified index and the inferred type name for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexAsync``1(``0,System.String,Nest.IndexParameters)">
            <summary>
            Index object to the specified index and the inferred type name for T, using index parameters to further control the operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexAsync``1(``0,System.String,System.String)">
            <summary>
            Index object to the specified index and the specified type name
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexAsync``1(``0,System.String,System.String,Nest.IndexParameters)">
            <summary>
            Index object to the specified index and the specified type name, using index parameters to further control the operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexAsync``1(``0,System.String,System.String,System.String)">
            <summary>
            Index object to the specified index and the specified type name and force the id of the object to update
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexAsync``1(``0,System.String,System.String,System.String,Nest.IndexParameters)">
            <summary>
            Index object to the specified index and the specified type name and force the id of the object to update, using index parameters to further control the operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexAsync``1(``0,System.String,System.String,System.Int32)">
            <summary>
            Index object to the specified index and the specified type name and force the id of the object to update
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexAsync``1(``0,System.String,System.String,System.Int32,Nest.IndexParameters)">
            <summary>
            Index object to the specified index and the specified type name and force the id of the object to update, using index parameters to further control the operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexMany``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Index objects to the default index and the inferred type name for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexMany``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}})">
            <summary>
            Index objects to the default index and the inferred type name for T, using bulk parameters to control the individual objects
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexMany``1(System.Collections.Generic.IEnumerable{``0},Nest.SimpleBulkParameters)">
            <summary>
            Index objects to the default index and the inferred type name for T
            and SimpleBulkParameters to control the entire operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexMany``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},Nest.SimpleBulkParameters)">
            <summary>
            Index objects to the default index and the inferred type name for T, using bulk parameters to control the individual objects
            and SimpleBulkParameters to control the entire operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexMany``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Index objects to the specified index and the inferred type name for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexMany``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String)">
            <summary>
            Index objects to the specified index and the inferred type name for T, using bulk parameters to control the individual objects
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexMany``1(System.Collections.Generic.IEnumerable{``0},System.String,Nest.SimpleBulkParameters)">
            <summary>
            Index objects to the specified index and the inferred type name for T
            and SimpleBulkParameters to control the entire operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexMany``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String,Nest.SimpleBulkParameters)">
            <summary>
            Index objects to the specified index and the inferred type name for T, using bulk parameters to control the individual objects
            and SimpleBulkParameters to control the entire operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexMany``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>
            Index objects to the specified index and the specified type name
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexMany``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String,System.String)">
            <summary>
            Index objects to the specified index and the specified type name, using bulk parameters to control the individual objects
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexMany``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,Nest.SimpleBulkParameters)">
            <summary>
            Index objects to the specified index and the specified type name
            and SimpleBulkParameters to control the entire operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexMany``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String,System.String,Nest.SimpleBulkParameters)">
            <summary>
            Index objects to the specified index and the specified type name, using bulk parameters to control the individual objects
            and SimpleBulkParameters to control the entire operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexManyAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Index objects to the default index and the inferred type name for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexManyAsync``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}})">
            <summary>
            Index objects to the default index and the inferred type name for T, using bulk parameters to control the individual objects
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexManyAsync``1(System.Collections.Generic.IEnumerable{``0},Nest.SimpleBulkParameters)">
            <summary>
            Index objects to the default index and the inferred type name for T
            and SimpleBulkParameters to control the entire operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexManyAsync``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},Nest.SimpleBulkParameters)">
            <summary>
            Index objects to the default index and the inferred type name for T, using bulk parameters to control the individual objects
            and SimpleBulkParameters to control the entire operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexManyAsync``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Index objects to the specified index and the inferred type name for T
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexManyAsync``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String)">
            <summary>
            Index objects to the specified index and the inferred type name for T, using bulk parameters to control the individual objects
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexManyAsync``1(System.Collections.Generic.IEnumerable{``0},System.String,Nest.SimpleBulkParameters)">
            <summary>
            Index objects to the specified index and the inferred type name for T
            and SimpleBulkParameters to control the entire operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexManyAsync``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String,Nest.SimpleBulkParameters)">
            <summary>
            Index objects to the specified index and the inferred type name for T, using bulk parameters to control the individual objects
            and SimpleBulkParameters to control the entire operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexManyAsync``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>
            Index objects to the specified index and the specified type name
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexManyAsync``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String,System.String)">
            <summary>
            Index objects to the specified index and the specified type name, using bulk parameters to control the individual objects
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexManyAsync``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,Nest.SimpleBulkParameters)">
            <summary>
            Index objects to the specified index and the specified type name
            and SimpleBulkParameters to control the entire operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.IndexManyAsync``1(System.Collections.Generic.IEnumerable{Nest.BulkParameters{``0}},System.String,System.String,Nest.SimpleBulkParameters)">
            <summary>
            Index objects to the specified index and the specified type name, using bulk parameters to control the individual objects
            and SimpleBulkParameters to control the entire operation
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.ToResponse``1(Nest.ConnectionStatus,System.Boolean)">
            <summary>
            Returns a response of type R based on the connection status without parsing status.Result into R
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.ElasticClient.ToParsedResponse``1(Nest.ConnectionStatus,System.Boolean,System.Collections.Generic.IEnumerable{Newtonsoft.Json.JsonConverter})">
            <summary>
            Returns a response of type R based on the connection status by trying parsing status.Result into R
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.ElasticClient.Search(System.Func{Nest.SearchDescriptor{System.Object},Nest.SearchDescriptor{System.Object}})">
            <summary>
            Synchronously search using dynamic as its return type.
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Search``1(System.Func{Nest.SearchDescriptor{``0},Nest.SearchDescriptor{``0}})">
            <summary>
            Synchronously search using T as the return type
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.Search``1(Nest.SearchDescriptor{``0})">
            <summary>
            Synchronously search using T as the return type
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.SearchRaw``1(System.String,System.String)">
            <summary>
            Synchronously search using T as the return type, string based.
            </summary>
            <param name="path">EXPERT OPTION: Pass the path and querystring used to perform the search on, when null it will be infered from the type</param>
        </member>
        <member name="M:Nest.ElasticClient.SearchRawAsync``1(System.String,System.String)">
            <summary>
            Asynchronously search using T as the return type, string based.
            </summary>
            <param name="path">EXPERT OPTION: Pass the path and querystring used to perform the search on, when null it will be infered from the type</param>
        </member>
        <member name="M:Nest.ElasticClient.SearchAsync(System.Func{Nest.SearchDescriptor{System.Object},Nest.SearchDescriptor{System.Object}})">
            <summary>
            Asynchronously search using dynamic as its return type.
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.SearchAsync``1(System.Func{Nest.SearchDescriptor{``0},Nest.SearchDescriptor{``0}})">
            <summary>
            Asynchronously search using T as the return type
            </summary>
        </member>
        <member name="M:Nest.ElasticClient.SearchAsync``1(Nest.SearchDescriptor{``0})">
            <summary>
            Asynchronously search using T as the return type
            </summary>
        </member>
        <member name="P:Nest.ElasticClient.IsValid">
            <summary>
            Validates the connection once and returns a bool whether NEST could connect to elasticsearch.
            </summary>
        </member>
        <member name="P:Nest.ElasticClient.VersionInfo">
            <summary>
            Return the version info that was set when NEST did its one off sanity checks
            </summary>
        </member>
        <member name="M:Nest.MultiSearchDescriptor.FixedPath(System.String,System.String)">
            <summary>
            Allows you to perform the multi search on a fixed path. 
            Each operation that doesn't specify an index or type will use this fixed index/type
            over the default infered index and type.
            </summary>
        </member>
        <member name="M:Nest.TemplateMappingDescriptor.InitializeUsing(Nest.TemplateMapping)">
            <summary>
            Initialize the descriptor using the values from for instance a previous Get Template Mapping call.
            </summary>
        </member>
        <member name="M:Nest.BulkCreateDescriptor`1.Index(System.String)">
            <summary>
            Manually set the index, default to the default index or the fixed index set on the bulk operation
            </summary>
        </member>
        <member name="M:Nest.BulkCreateDescriptor`1.Type(System.String)">
            <summary>
            Manualy set the type to get the object from, default to whatever
            T will be inferred to if not passed or the fixed type set on the parent bulk operation
            </summary>
        </member>
        <member name="M:Nest.BulkCreateDescriptor`1.Type(System.Type)">
            <summary>
            Manually set the type of which a typename will be inferred
            </summary>
        </member>
        <member name="M:Nest.BulkCreateDescriptor`1.Id(System.Int32)">
            <summary>
            Manually set the id for the newly created object
            </summary>
        </member>
        <member name="M:Nest.BulkCreateDescriptor`1.Id(System.String)">
            <summary>
            Manually set the id for the newly created object
            </summary>
        </member>
        <member name="M:Nest.BulkCreateDescriptor`1.Object(`0)">
            <summary>
            The object to update, if id is not manually set it will be inferred from the object
            </summary>
        </member>
        <member name="M:Nest.BulkDescriptor.FixedPath(System.String,System.String)">
            <summary>
            Allows you to perform the multiget on a fixed path. 
            Each operation that doesn't specify an index or type will use this fixed index/type
            over the default infered index and type.
            </summary>
        </member>
        <member name="M:Nest.BulkIndexDescriptor`1.Index(System.String)">
            <summary>
            Manually set the index, default to the default index or the fixed index set on the bulk operation
            </summary>
        </member>
        <member name="M:Nest.BulkIndexDescriptor`1.Type(System.String)">
            <summary>
            Manualy set the type to get the object from, default to whatever
            T will be inferred to if not passed or the fixed type set on the parent bulk operation
            </summary>
        </member>
        <member name="M:Nest.BulkIndexDescriptor`1.Type(System.Type)">
            <summary>
            Manually set the type of which a typename will be inferred
            </summary>
        </member>
        <member name="M:Nest.BulkIndexDescriptor`1.Id(System.Int32)">
            <summary>
            Manually set the id for the newly created object
            </summary>
        </member>
        <member name="M:Nest.BulkIndexDescriptor`1.Id(System.String)">
            <summary>
            Manually set the id for the newly created object
            </summary>
        </member>
        <member name="M:Nest.BulkIndexDescriptor`1.Object(`0)">
            <summary>
            The object to index, if id is not manually set it will be inferred from the object
            </summary>
        </member>
        <member name="M:Nest.BulkDeleteDescriptor`1.Index(System.String)">
            <summary>
            Manually set the index, default to the default index or the fixed index set on the bulk operation
            </summary>
        </member>
        <member name="M:Nest.BulkDeleteDescriptor`1.Type(System.String)">
            <summary>
            Manualy set the type to get the object from, default to whatever
            T will be inferred to if not passed or the fixed type set on the parent bulk operation
            </summary>
        </member>
        <member name="M:Nest.BulkDeleteDescriptor`1.Type(System.Type)">
            <summary>
            Manually set the type of which a typename will be inferred
            </summary>
        </member>
        <member name="M:Nest.BulkDeleteDescriptor`1.Id(System.Int32)">
            <summary>
            Manually set the id for the newly created object
            </summary>
        </member>
        <member name="M:Nest.BulkDeleteDescriptor`1.Id(System.String)">
            <summary>
            Manually set the id for the newly created object
            </summary>
        </member>
        <member name="M:Nest.BulkDeleteDescriptor`1.Object(`0)">
            <summary>
            The object to infer the id off, (if id is not passed using Id())
            </summary>
        </member>
        <member name="T:Nest.Language">
            <summary>
            Language types used for language analyzers
            </summary>
        </member>
        <member name="T:Nest.LanguageAnalyzer">
            <summary>
            A set of analyzers aimed at analyzing specific language text. 
            </summary>
        </member>
        <member name="P:Nest.LanguageAnalyzer.StopWords">
            <summary>
            A list of stopword to initialize the stop filter with. Defaults to the english stop words.
            </summary>
        </member>
        <member name="P:Nest.LanguageAnalyzer.StopwordsPath">
            <summary>
            A path (either relative to config location, or absolute) to a stopwords file configuration.
            </summary>
        </member>
        <member name="T:Nest.KeywordAnalyzer">
            <summary>
            An analyzer of type keyword that “tokenizes” an entire stream as a single token. This is useful for data like zip codes, ids and so on. 
            <para>Note, when using mapping definitions, it make more sense to simply mark the field as not_analyzed.</para>
            </summary>
        </member>
        <member name="T:Nest.PatternAnalyzer">
            <summary>
            An analyzer of type pattern that can flexibly separate text into terms via a regular expression. 
            </summary>
        </member>
        <member name="T:Nest.StopAnalyzer">
            <summary>
            An analyzer of type stop that is built using a Lower Case Tokenizer, with Stop Token Filter.
            </summary>
        </member>
        <member name="P:Nest.StopAnalyzer.StopWords">
            <summary>
            A list of stopword to initialize the stop filter with. Defaults to the english stop words.
            </summary>
        </member>
        <member name="P:Nest.StopAnalyzer.StopwordsPath">
            <summary>
            A path (either relative to config location, or absolute) to a stopwords file configuration.
            </summary>
        </member>
        <member name="T:Nest.WhitespaceAnalyzer">
            <summary>
            An analyzer of type whitespace that is built using a Whitespace Tokenizer.
            </summary>
        </member>
        <member name="T:Nest.SimpleAnalyzer">
            <summary>
            An analyzer of type simple that is built using a Lower Case Tokenizer.
            </summary>
        </member>
        <member name="T:Nest.HtmlStripCharFilter">
            <summary>
            A char filter of type html_strip stripping out HTML elements from an analyzed text.
            </summary>
        </member>
        <member name="T:Nest.MappingCharFilter">
            <summary>
            A char filter of type mapping replacing characters of an analyzed text with given mapping.
            </summary>
        </member>
        <member name="T:Nest.AsciiFoldingTokenFilter">
            <summary>
            A token filter of type asciifolding that converts alphabetic, numeric, and symbolic Unicode characters which are 
            <para> not in the first 127 ASCII characters (the “Basic Latin” Unicode block) into their ASCII equivalents, if one exists.</para>
            </summary>
        </member>
        <member name="T:Nest.CompoundWordTokenFilter">
            <summary>
            Token filters that allow to decompose compound words.
            </summary>
        </member>
        <member name="T:Nest.TrimTokenFilter">
            <summary>
            The trim token filter trims surrounding whitespaces around a token.
            </summary>
        </member>
        <member name="T:Nest.UniqueTokenFilter">
            <summary>
            The unique token filter can be used to only index unique tokens during analysis. By default it is applied on all the token stream
            </summary>
        </member>
        <member name="P:Nest.UniqueTokenFilter.OnlyOnSamePosition">
            <summary>
             If only_on_same_position is set to true, it will only remove duplicate tokens on the same position.
            </summary>
        </member>
        <member name="T:Nest.TruncateTokenFilter">
            <summary>
            The truncate token filter can be used to truncate tokens into a specific length. This can come in handy with keyword (single token) 
            <para> based mapped fields that are used for sorting in order to reduce memory usage.</para>
            </summary>
        </member>
        <member name="P:Nest.TruncateTokenFilter.Length">
            <summary>
            length parameter which control the number of characters to truncate to, defaults to 10.
            </summary>
        </member>
        <member name="T:Nest.ElisionTokenFilter">
            <summary>
            A token filter which removes elisions. For example, “l’avion” (the plane) will tokenized as “avion” (plane).
            </summary>
        </member>
        <member name="P:Nest.ElisionTokenFilter.Articles">
            <summary>
            Accepts articles setting which is a set of stop words articles
            </summary>
        </member>
        <member name="T:Nest.ReverseTokenFilter">
            <summary>
            A token filter of type reverse that simply reverses the tokens.
            </summary>
        </member>
        <member name="T:Nest.PhoneticTokenFilter">
            <summary>
            The phonetic token filter is provided as a plugin.
            </summary>
        </member>
        <member name="T:Nest.SnowballTokenFilter">
            <summary>
            A filter that stems words using a Snowball-generated stemmer.
            </summary>
        </member>
        <member name="T:Nest.KStemTokenFilter">
             <summary>
            The kstem token filter is a high performance filter for english. 
            <para> All terms must already be lowercased (use lowercase filter) for this filter to work correctly.</para>
             </summary>
        </member>
        <member name="T:Nest.KeywordMarkerTokenFilter">
            <summary>
            Protects words from being modified by stemmers. Must be placed before any stemming filters.
            </summary>
        </member>
        <member name="T:Nest.StemmerTokenFilter">
            <summary>
            A filter that stems words (similar to snowball, but with more options).
            </summary>
        </member>
        <member name="T:Nest.PorterStemTokenFilter">
            <summary>
            A token filter of type porterStem that transforms the token stream as per the Porter stemming algorithm.
            </summary>
        </member>
        <member name="T:Nest.LowercaseTokenFilter">
             <summary>
             A token filter of type lowercase that normalizes token text to lower case.
            <para> Lowercase token filter supports Greek and Turkish lowercase token filters through the language parameter.</para>
             </summary>
        </member>
        <member name="T:Nest.LengthTokenFilter">
            <summary>
            A token filter of type length that removes words that are too long or too short for the stream.
            </summary>
        </member>
        <member name="T:Nest.StandardTokenFilter">
            <summary>
            A token filter of type standard that normalizes tokens extracted with the Standard Tokenizer.
            </summary>
        </member>
        <member name="T:Nest.PathHierarchyTokenizer">
             <summary>
             The path_hierarchy tokenizer takes something like this:
            <para>/something/something/else</para>
            <para>And produces tokens:</para>
            <para></para>
            <para>/something</para>
            <para>/something/something</para>
            <para>/something/something/else</para>
             </summary>
        </member>
        <member name="P:Nest.PathHierarchyTokenizer.Delimiter">
            <summary>
            The character delimiter to use, defaults to /.
            </summary>
        </member>
        <member name="P:Nest.PathHierarchyTokenizer.Replacement">
            <summary>
            An optional replacement character to use. Defaults to the delimiter
            </summary>
        </member>
        <member name="P:Nest.PathHierarchyTokenizer.BufferSize">
            <summary>
            The buffer size to use, defaults to 1024.
            </summary>
        </member>
        <member name="P:Nest.PathHierarchyTokenizer.Reverse">
            <summary>
            Generates tokens in reverse order, defaults to false.
            </summary>
        </member>
        <member name="P:Nest.PathHierarchyTokenizer.Skip">
            <summary>
            Controls initial tokens to skip, defaults to 0.
            </summary>
        </member>
        <member name="T:Nest.UaxEmailUrlTokenizer">
            <summary>
            A tokenizer of type uax_url_email which works exactly like the standard tokenizer, but tokenizes emails and urls as single tokens
            </summary>
        </member>
        <member name="P:Nest.UaxEmailUrlTokenizer.MaximumTokenLength">
            <summary>
            The maximum token length. If a token is seen that exceeds this length then it is discarded. Defaults to 255.
            </summary>
        </member>
        <member name="T:Nest.PatternTokenizer">
            <summary>
            A tokenizer of type pattern that can flexibly separate text into terms via a regular expression. 
            </summary>
        </member>
        <member name="P:Nest.PatternTokenizer.Pattern">
            <summary>
            The regular expression pattern, defaults to \W+.
            </summary>
        </member>
        <member name="P:Nest.PatternTokenizer.Flags">
            <summary>
            The regular expression flags.
            </summary>
        </member>
        <member name="P:Nest.PatternTokenizer.Group">
            <summary>
            Which group to extract into tokens. Defaults to -1 (split).
            </summary>
        </member>
        <member name="T:Nest.WhitespaceTokenizer">
            <summary>
            A tokenizer of type whitespace that divides text at whitespace.
            </summary>
        </member>
        <member name="T:Nest.StandardTokenizer">
            <summary>
            A tokenizer of type standard providing grammar based tokenizer that is a good tokenizer for most European language documents. 
            <para>The tokenizer implements the Unicode Text Segmentation algorithm, as specified in Unicode Standard Annex #29.</para>
            </summary>
        </member>
        <member name="P:Nest.StandardTokenizer.MaximumTokenLength">
            <summary>
            The maximum token length. If a token is seen that exceeds this length then it is discarded. Defaults to 255.
            </summary>
        </member>
        <member name="T:Nest.NGramTokenizer">
            <summary>
            A tokenizer of type nGram.
            </summary>
        </member>
        <member name="T:Nest.LowercaseTokenizer">
            <summary>
            A tokenizer of type lowercase that performs the function of Letter Tokenizer and Lower Case Token Filter together. 
            <para>It divides text at non-letters and converts them to lower case. </para>
            <para>While it is functionally equivalent to the combination of Letter Tokenizer and Lower Case Token Filter, </para>
            <para>there is a performance advantage to doing the two tasks at once, hence this (redundant) implementation.</para>
            </summary>
        </member>
        <member name="T:Nest.LetterTokenizer">
            <summary>
            A tokenizer of type letter that divides text at non-letters. That’s to say, it defines tokens as maximal strings of adjacent letters. 
            <para>Note, this does a decent job for most European languages, but does a terrible job for some Asian languages, where words are not separated by spaces.</para>
            </summary>
        </member>
        <member name="T:Nest.EdgeNGramTokenizer">
            <summary>
            A tokenizer of type edgeNGram.
            </summary>
        </member>
        <member name="T:Nest.KeywordTokenizer">
            <summary>
            A tokenizer of type keyword that emits the entire input as a single input.
            </summary>
        </member>
        <member name="P:Nest.KeywordTokenizer.BufferSize">
            <summary>
            The term buffer size. Defaults to 256.
            </summary>
        </member>
        <member name="T:Nest.EdgeNGramTokenFilter">
            <summary>
            A token filter of type edgeNGram.
            </summary>
        </member>
        <member name="M:Nest.CreateIndexDescriptor.InitializeUsing(Nest.IndexSettings)">
            <summary>
            Initialize the descriptor using the values from for instance a previous Get Index Settings call.
            </summary>
        </member>
        <member name="M:Nest.CreateIndexDescriptor.NumberOfShards(System.Int32)">
            <summary>
            Set the number of shards (if possible) for the new index.
            </summary>
            <param name="shards"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.CreateIndexDescriptor.NumberOfReplicas(System.Int32)">
            <summary>
            Set the number of replicas (if possible) for the new index.
            </summary>
            <param name="replicas"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.CreateIndexDescriptor.Settings(System.Action{Nest.FluentDictionary{System.String,System.Object}})">
            <summary>
            Set/Update settings, the index.* prefix is not needed for the keys.
            </summary>
        </member>
        <member name="M:Nest.CreateIndexDescriptor.RemoveMapping(System.String)">
            <summary>
            Remove an existing mapping by name
            </summary>
        </member>
        <member name="M:Nest.CreateIndexDescriptor.RemoveMapping``1">
            <summary>
            Remove an exisiting mapping by inferred type name
            </summary>
        </member>
        <member name="M:Nest.CreateIndexDescriptor.AddMapping``1(System.Func{Nest.RootObjectMappingDescriptor{``0},Nest.RootObjectMappingDescriptor{``0}})">
            <summary>
            Add a new mapping for T
            </summary>
        </member>
        <member name="M:Nest.CreateIndexDescriptor.AddMapping``1(Nest.RootObjectMapping,System.Func{Nest.RootObjectMappingDescriptor{``0},Nest.RootObjectMappingDescriptor{``0}})">
            <summary>
            Add a new mapping using the first rootObjectMapping parameter as the base to construct the new mapping.
            Handy if you wish to reuse a mapping.
            </summary>
        </member>
        <member name="M:Nest.CreateIndexDescriptor.Analysis(System.Func{Nest.AnalysisDescriptor,Nest.AnalysisDescriptor})">
            <summary>
            Set up analysis tokenizers, filters, analyzers
            </summary>
        </member>
        <member name="M:Nest.MoreLikeThisDescriptor`1.Index(System.String)">
            <summary>
            Explicitly specify an index, otherwise the default index for T is used.
            </summary>
        </member>
        <member name="M:Nest.MoreLikeThisDescriptor`1.Type(System.String)">
            <summary>
            Explicitly specify an type, otherwise the default type for T is used.
            </summary>
        </member>
        <member name="M:Nest.MoreLikeThisDescriptor`1.Id(System.Int32)">
            <summary>
            Explicitly specify an id, otherwise the default index for T is used.
            Either Id() or Object() MUST be called for Nest to infer an id. 
            If both are specified Id() will win
            </summary>
        </member>
        <member name="M:Nest.MoreLikeThisDescriptor`1.Id(System.String)">
            <summary>
            Explicitly specify an id, otherwise the default index for T is used.
            Either Id() or Object() MUST be called for Nest to infer an id. 
            If both are specified Id() will win
            </summary>
        </member>
        <member name="M:Nest.MoreLikeThisDescriptor`1.Object(`0)">
            <summary>
            Specify an object to infer the id from
            Either Id() or Object() MUST be called for Nest to infer an id. 
            If both are specified Id() will win
            </summary>
        </member>
        <member name="M:Nest.MoreLikeThisDescriptor`1.Options(System.Func{Nest.MoreLikeThisQueryDescriptor{`0},Nest.MoreLikeThisQueryDescriptor{`0}})">
            <summary>
            Specify on which fields the _mlt should act and how it should behave
            </summary>
        </member>
        <member name="M:Nest.MoreLikeThisDescriptor`1.Search(System.Func{Nest.SearchDescriptor{`0},Nest.SearchDescriptor{`0}})">
            <summary>
            Optionally specify more search options such as facets, from/to etcetera.
            </summary>
        </member>
        <member name="M:Nest.NestedObjectMappingDescriptor`2.MapFromAttributes(System.Int32)">
            <summary>
            Convenience method to map from most of the object from the attributes/properties.
            Later calls on the fluent interface can override whatever is set is by this call. 
            This helps mapping all the ints as ints, floats as floats etcetera withouth having to be overly verbose in your fluent mapping
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.ObjectMappingDescriptor`2.MapFromAttributes(System.Int32)">
            <summary>
            Convenience method to map from most of the object from the attributes/properties.
            Later calls on the fluent interface can override whatever is set is by this call. 
            This helps mapping all the ints as ints, floats as floats etcetera withouth having to be overly verbose in your fluent mapping
            </summary>
            <returns></returns>
        </member>
        <member name="P:Nest.BinaryMapping.IndexName">
            <summary>
            The name of the field that will be stored in the index. Defaults to the property/field name.
            </summary>
        </member>
        <member name="P:Nest.BooleanMapping.IndexName">
            <summary>
            The name of the field that will be stored in the index. Defaults to the property/field name.
            </summary>
        </member>
        <member name="P:Nest.DateMapping.IndexName">
            <summary>
            The name of the field that will be stored in the index. Defaults to the property/field name.
            </summary>
        </member>
        <member name="P:Nest.NumberMapping.IndexName">
            <summary>
            The name of the field that will be stored in the index. Defaults to the property/field name.
            </summary>
        </member>
        <member name="P:Nest.StringMapping.IndexName">
            <summary>
            The name of the field that will be stored in the index. Defaults to the property/field name.
            </summary>
        </member>
        <member name="M:Nest.RootObjectMappingDescriptor`1.MapFromAttributes(System.Int32)">
            <summary>
            Convenience method to map from most of the object from the attributes/properties.
            Later calls on the fluent interface can override whatever is set is by this call. 
            This helps mapping all the ints as ints, floats as floats etcetera withouth having to be overly verbose in your fluent mapping
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.RootObjectMappingDescriptor`1.TypeName(System.String)">
            <summary>
            Explicitly set the typename otherwise it will infer the typename on its own (lowercase and pluralized).
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.RootObjectMappingDescriptor`1.IndexName(System.String)">
            <summary>
            Explicitly set the index name otherwise it will infer the indexname based on the type
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.RootObjectMappingDescriptor`1.IndexNames(System.String[])">
            <summary>
            Explicitly set the index names otherwise it will infer the indexname based on the type
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.RootObjectMappingDescriptor`1.IndexNames(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Explicitly set the index names otherwise it will infer the indexname based on the type
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.RootObjectMappingDescriptor`1.IgnoreConflicts(System.Boolean)">
            <summary>
            When an existing mapping already exists under the given type, the two mapping definitions, the one already defined, and the new ones are merged. 
            The ignore_conflicts parameters can be used to control if conflicts should be ignored or not, by default, it is set to false which means conflicts are not ignored.
            The definition of conflict is really dependent on the type merged, but in general, if a different core type is defined, it is considered as a conflict. 
            New mapping definitions can be added to object types, and core type mapping can be upgraded to multi_field type.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.MultiGetDescriptor.FixedPath(System.String,System.String)">
            <summary>
            Allows you to perform the multiget on a fixed path. 
            The index and optionally type specified here take precedence over the chained get operations.
            </summary>
        </member>
        <member name="T:Nest.InMemoryConnection">
            <summary>
            
            </summary>
        </member>
        <member name="M:Nest.SimpleGetDescriptor`1.Index(System.String)">
            <summary>
            Manually set the index, default to the default index or the index set for the type on the connectionsettings.
            </summary>
        </member>
        <member name="M:Nest.SimpleGetDescriptor`1.Type(System.String)">
            <summary>
            Manualy set the type to get the object from, default to whatever
            T will be inferred to if not passed.
            </summary>
        </member>
        <member name="M:Nest.SimpleGetDescriptor`1.Type(System.Type)">
            <summary>
            Manually set the type of which a typename will be inferred
            </summary>
        </member>
        <member name="M:Nest.SimpleGetDescriptor`1.Fields(System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Allows to selectively load specific fields for each document 
            represented by a search hit. Defaults to load the internal _source field.
            </summary>
        </member>
        <member name="M:Nest.SimpleGetDescriptor`1.Fields(System.String[])">
            <summary>
            Allows to selectively load specific fields for each document 
            represented by a search hit. Defaults to load the internal _source field.
            </summary>
        </member>
        <member name="M:Nest.GetDescriptor`1.Index(System.String)">
            <summary>
            Manually set the index, default to the default index or the index set for the type on the connectionsettings.
            </summary>
        </member>
        <member name="M:Nest.GetDescriptor`1.Type(System.String)">
            <summary>
            Manualy set the type to get the object from, default to whatever
            T will be inferred to if not passed.
            </summary>
        </member>
        <member name="M:Nest.GetDescriptor`1.Type(System.Type)">
            <summary>
            Manually set the type of which a typename will be inferred
            </summary>
        </member>
        <member name="M:Nest.GetDescriptor`1.Refresh(System.Boolean)">
            <summary>
            The refresh parameter can be set to true in order to refresh the relevant shard before the get operation and make it searchable. Setting it to true should be done after careful thought and verification that this does not cause a heavy load on the system (and slows down indexing).
            </summary>
        </member>
        <member name="M:Nest.GetDescriptor`1.Routing(System.String)">
            <summary>
            When indexing using the ability to control the routing, in order to get a document, the routing value should also be provided.
            </summary>
        </member>
        <member name="M:Nest.GetDescriptor`1.Realtime(System.Boolean)">
            <summary>
            By default, the get API is realtime, and is not affected by the refresh rate of the index (when data will become visible for search).
            </summary>
        </member>
        <member name="M:Nest.GetDescriptor`1.Fields(System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Allows to selectively load specific fields for each document 
            represented by a search hit. Defaults to load the internal _source field.
            </summary>
        </member>
        <member name="M:Nest.GetDescriptor`1.Fields(System.String[])">
            <summary>
            Allows to selectively load specific fields for each document 
            represented by a search hit. Defaults to load the internal _source field.
            </summary>
        </member>
        <member name="M:Nest.GetDescriptor`1.Preference(System.String)">
            <summary>
            <para>
            Controls a preference of which shard replicas to execute the search request on. 
            By default, the operation is randomized between the each shard replicas.
            </para>
            <para>
            Custom (string) value: A custom value will be used to guarantee that the same shards
            will be used for the same custom value. This can help with “jumping values” 
            when hitting different shards in different refresh states. 
            A sample value can be something like the web session id, or the user name.
            </para>
            </summary>
        </member>
        <member name="M:Nest.GetDescriptor`1.ExecuteOnPrimary">
            <summary>
            <para>
            Controls a preference of which shard replicas to execute the search request on. 
            By default, the operation is randomized between the each shard replicas.
            </para>
            <para>
            The operation will go and be executed only on the primary shards.
            </para>
            </summary>
        </member>
        <member name="M:Nest.GetDescriptor`1.ExecuteOnLocalShard">
            <summary>
            <para>
            Controls a preference of which shard replicas to execute the search request on. 
            By default, the operation is randomized between the each shard replicas.
            </para>
            <para>
            The operation will prefer to be executed on a local allocated shard is possible.
            </para>
            </summary>
        </member>
        <member name="T:Nest.NgramTokenFilter">
            <summary>
            A token filter of type nGram.
            </summary>
        </member>
        <member name="T:Nest.SynonymTokenFilter">
            <summary>
            The synonym token filter allows to easily handle synonyms during the analysis process. 
            </summary>
        </member>
        <member name="P:Nest.ValidateResponse.Explanations">
            <summary>
            Gets the explanations if Explain() was set.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.QueryString(System.Action{Nest.QueryStringDescriptor{`0}})">
            <summary>
            A query that uses a query parser in order to parse its content.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Terms(System.String,System.String[])">
            <summary>
            A query that match on any (configurable) of the provided terms. This is a simpler syntax query for using a bool query with several term queries in the should clauses.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Terms(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String[])">
            <summary>
            A query that match on any (configurable) of the provided terms. This is a simpler syntax query for using a bool query with several term queries in the should clauses.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.TermsDescriptor(System.Action{Nest.TermsQueryDescriptor{`0}})">
            <summary>
            A query that match on any (configurable) of the provided terms. This is a simpler syntax query for using a bool query with several term queries in the should clauses.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Fuzzy(System.Action{Nest.FuzzyQueryDescriptor{`0}})">
            <summary>
            A fuzzy based query that uses similarity based on Levenshtein (edit distance) algorithm.
            Warning: this query is not very scalable with its default prefix length of 0 – in this case,
            every term will be enumerated and cause an edit score calculation or max_expansions is not set.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.FuzzyNumeric(System.Action{Nest.FuzzyNumericQueryDescriptor{`0}})">
            <summary>
            fuzzy query on a numeric field will result in a range query “around” the value using the min_similarity value
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.FuzzyDate(System.Action{Nest.FuzzyDateQueryDescriptor{`0}})">
            <summary>
            fuzzy query on a numeric field will result in a range query “around” the value using the min_similarity value
            </summary>
            <param name="selector"></param>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Text(System.Action{Nest.TextQueryDescriptor{`0}})">
            <summary>
            The default text query is of type boolean. It means that the text provided is analyzed and the analysis 
            process constructs a boolean query from the provided text.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.TextPhrase(System.Action{Nest.TextPhraseQueryDescriptor{`0}})">
            <summary>
            The text_phrase query analyzes the text and creates a phrase query out of the analyzed text. 
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.TextPhrasePrefix(System.Action{Nest.TextPhrasePrefixQueryDescriptor{`0}})">
            <summary>
            The text_phrase_prefix is the same as text_phrase, expect it allows for prefix matches on the last term 
            in the text
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Nested(System.Action{Nest.NestedQueryDescriptor{`0}})">
            <summary>
            Nested query allows to query nested objects / docs (see nested mapping). The query is executed against the 
            nested objects / docs as if they were indexed as separate docs (they are, internally) and resulting in the
            root parent doc (or parent nested mapping).
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Indices(System.Action{Nest.IndicesQueryDescriptor{`0}})">
            <summary>
            The indices query can be used when executed across multiple indices, allowing to have a query that executes
            only when executed on an index that matches a specific list of indices, and another query that executes 
            when it is executed on an index that does not match the listed indices.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Range(System.Action{Nest.RangeQueryDescriptor{`0}})">
            <summary>
            Matches documents with fields that have terms within a certain range. The type of the Lucene query depends
            on the field type, for string fields, the TermRangeQuery, while for number/date fields, the query is
            a NumericRangeQuery
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.FuzzyLikeThis(System.Action{Nest.FuzzyLikeThisDescriptor{`0}})">
            <summary>
            Fuzzy like this query find documents that are “like” provided text by running it against one or more fields.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.MoreLikeThis(System.Action{Nest.MoreLikeThisQueryDescriptor{`0}})">
            <summary>
            More like this query find documents that are “like” provided text by running it against one or more fields.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.HasChild``1(System.Action{Nest.HasChildQueryDescriptor{``0}})">
            <summary>
            The has_child query works the same as the has_child filter, by automatically wrapping the filter with a 
            constant_score.
            </summary>
            <typeparam name="K">Type of the child</typeparam>
        </member>
        <member name="M:Nest.QueryDescriptor`1.TopChildren``1(System.Action{Nest.TopChildrenQueryDescriptor{``0}})">
            <summary>
            The top_children query runs the child query with an estimated hits size, and out of the hit docs, aggregates 
            it into parent docs. If there aren’t enough parent docs matching the requested from/size search request, 
            then it is run again with a wider (more hits) search.
            </summary>
            <typeparam name="K">Type of the child</typeparam>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Filtered(System.Action{Nest.FilteredQueryDescriptor{`0}})">
            <summary>
            A query that applies a filter to the results of another query. This query maps to Lucene FilteredQuery.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Dismax(System.Action{Nest.DismaxQueryDescriptor{`0}})">
            <summary>
            A query that generates the union of documents produced by its subqueries, and that scores each document 
            with the maximum score for that document as produced by any subquery, plus a tie breaking increment for 
            any additional matching subqueries.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.ConstantScore(System.Action{Nest.ConstantScoreQueryDescriptor{`0}})">
            <summary>
            A query that wraps a filter or another query and simply returns a constant score equal to the query boost 
            for every document in the filter. Maps to Lucene ConstantScoreQuery.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.CustomBoostFactor(System.Action{Nest.CustomBoostFactorQueryDescriptor{`0}})">
            <summary>
            custom_boost_factor query allows to wrap another query and multiply its score by the provided boost_factor.
            This can sometimes be desired since boost value set on specific queries gets normalized, while this 
            query boost factor does not.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.CustomScore(System.Action{Nest.CustomScoreQueryDescriptor{`0}})">
            <summary>
            custom_score query allows to wrap another query and customize the scoring of it optionally with a 
            computation derived from other field values in the doc (numeric ones) using script expression
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Bool(System.Action{Nest.BoolQueryDescriptor{`0}})">
            <summary>
            A query that matches documents matching boolean combinations of other queries. The bool query maps to 
            Lucene BooleanQuery. 
            It is built using one or more boolean clauses, each clause with a typed occurrence
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Boosting(System.Action{Nest.BoostingQueryDescriptor{`0}})">
            <summary>
            the boosting query can be used to effectively demote results that match a given query. 
            Unlike the “NOT” clause in bool query, this still selects documents that contain
            undesirable terms, but reduces their overall score.
            </summary>
            <param name="boostingQuery"></param>
        </member>
        <member name="M:Nest.QueryDescriptor`1.MatchAll(System.Nullable{System.Double},System.String)">
            <summary>
            A query that matches all documents. Maps to Lucene MatchAllDocsQuery.
            </summary>
            <param name="NormField">
            When indexing, a boost value can either be associated on the document level, or per field. 
            The match all query does not take boosting into account by default. In order to take 
            boosting into account, the norms_field needs to be provided in order to explicitly specify which
            field the boosting will be done on (Note, this will result in slower execution time).
            </param>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Term(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{System.Double})">
            <summary>
            Matches documents that have fields that contain a term (not analyzed). 
            The term query maps to Lucene TermQuery. 
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Term(System.String,System.String,System.Nullable{System.Double})">
            <summary>
            Matches documents that have fields that contain a term (not analyzed). 
            The term query maps to Lucene TermQuery. 
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Wildcard(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{System.Double},System.Nullable{Nest.RewriteMultiTerm})">
            <summary>
            Matches documents that have fields matching a wildcard expression (not analyzed). 
            Supported wildcards are *, which matches any character sequence (including the empty one), and ?, 
            which matches any single character. Note this query can be slow, as it needs to iterate 
            over many terms. In order to prevent extremely slow wildcard queries, a wildcard term should 
            not start with one of the wildcards * or ?. The wildcard query maps to Lucene WildcardQuery.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Wildcard(System.String,System.String,System.Nullable{System.Double},System.Nullable{Nest.RewriteMultiTerm})">
            <summary>
            Matches documents that have fields matching a wildcard expression (not analyzed). 
            Supported wildcards are *, which matches any character sequence (including the empty one), and ?,
            which matches any single character. Note this query can be slow, as it needs to iterate over many terms. 
            In order to prevent extremely slow wildcard queries, a wildcard term should not start with 
            one of the wildcards * or ?. The wildcard query maps to Lucene WildcardQuery.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Prefix(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{System.Double},System.Nullable{Nest.RewriteMultiTerm})">
            <summary>
            Matches documents that have fields containing terms with a specified prefix (not analyzed). 
            The prefix query maps to Lucene PrefixQuery. 
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Prefix(System.String,System.String,System.Nullable{System.Double},System.Nullable{Nest.RewriteMultiTerm})">
            <summary>
            Matches documents that have fields containing terms with a specified prefix (not analyzed). 
            The prefix query maps to Lucene PrefixQuery. 
            </summary>	
        </member>
        <member name="M:Nest.QueryDescriptor`1.Ids(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Filters documents that only have the provided ids. Note, this filter does not require 
            the _id field to be indexed since it works using the _uid field.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Ids(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Filters documents that only have the provided ids. 
            Note, this filter does not require the _id field to be indexed since
            it works using the _uid field.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.Ids(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Filters documents that only have the provided ids. 
            Note, this filter does not require the _id field to be indexed since 
            it works using the _uid field.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.SpanTerm(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Nullable{System.Double})">
            <summary>
            Matches spans containing a term. The span term query maps to Lucene SpanTermQuery. 
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.SpanTerm(System.String,System.String,System.Nullable{System.Double})">
            <summary>
            Matches spans containing a term. The span term query maps to Lucene SpanTermQuery. 
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.SpanFirst(System.Action{Nest.SpanFirstQueryDescriptor{`0}})">
            <summary>
            Matches spans near the beginning of a field. The span first query maps to Lucene SpanFirstQuery. 
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.SpanNear(System.Action{Nest.SpanNearQueryDescriptor{`0}})">
            <summary>
            Matches spans which are near one another. One can specify slop, the maximum number of 
            intervening unmatched positions, as well as whether matches are required to be in-order.
            The span near query maps to Lucene SpanNearQuery.
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.SpanOr(System.Action{Nest.SpanOrQueryDescriptor{`0}})">
            <summary>
            Matches the union of its span clauses. 
            The span or query maps to Lucene SpanOrQuery. 
            </summary>
        </member>
        <member name="M:Nest.QueryDescriptor`1.SpanNot(System.Action{Nest.SpanNotQueryDescriptor{`0}})">
            <summary>
            Removes matches which overlap with another span query. 
            The span not query maps to Lucene SpanNotQuery.
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Exists(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Filters documents where a specific field has a value in them.
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Exists(System.String)">
            <summary>
            Filters documents where a specific field has a value in them.
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Missing(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Filters documents where a specific field has no value in them.
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Missing(System.String)">
            <summary>
            Filters documents where a specific field has no value in them.
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Ids(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Filters documents that only have the provided ids. 
            Note, this filter does not require the _id field to be indexed since it works using the _uid field.
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Ids(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Filters documents that only have the provided ids. 
            Note, this filter does not require the _id field to be indexed since it works using the _uid field.
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Ids(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Filters documents that only have the provided ids. 
            Note, this filter does not require the _id field to be indexed since it works using the _uid field.
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.GeoBoundingBox(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.String,System.Nullable{Nest.GeoExecution})">
            <summary>
            A filter allowing to filter hits based on a point location using a bounding box
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.GeoBoundingBox(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Double,System.Double,System.Double,System.Double,System.Nullable{Nest.GeoExecution})">
            <summary>
            A filter allowing to filter hits based on a point location using a bounding box
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.GeoBoundingBox(System.String,System.Double,System.Double,System.Double,System.Double,System.Nullable{Nest.GeoExecution})">
            <summary>
            A filter allowing to filter hits based on a point location using a bounding box
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.GeoBoundingBox(System.String,System.String,System.String,System.Nullable{Nest.GeoExecution})">
            <summary>
            A filter allowing to filter hits based on a point location using a bounding box
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.GeoDistance(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{Nest.GeoDistanceFilterDescriptor})">
            <summary>
            Filters documents that include only hits that exists within a specific distance from a geo point. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.GeoDistance(System.String,System.Action{Nest.GeoDistanceFilterDescriptor})">
            <summary>
            Filters documents that include only hits that exists within a specific distance from a geo point. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.GeoDistanceRange(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{Nest.GeoDistanceRangeFilterDescriptor})">
            <summary>
            Filters documents that exists within a range from a specific point:
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.GeoDistanceRange(System.String,System.Action{Nest.GeoDistanceRangeFilterDescriptor})">
            <summary>
            Filters documents that exists within a range from a specific point:
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.GeoPolygon(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IEnumerable{System.Tuple{System.Double,System.Double}})">
            <summary>
            A filter allowing to include hits that only fall within a polygon of points. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.GeoPolygon(System.String,System.Collections.Generic.IEnumerable{System.Tuple{System.Double,System.Double}})">
            <summary>
            A filter allowing to include hits that only fall within a polygon of points. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.GeoPolygon(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String[])">
            <summary>
            A filter allowing to include hits that only fall within a polygon of points. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.GeoPolygon(System.String,System.String[])">
            <summary>
            A filter allowing to include hits that only fall within a polygon of points. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.HasChild``1(System.Action{Nest.HasChildFilterDescriptor{``0}})">
            <summary>
            The has_child filter accepts a query and the child type to run against, 
            and results in parent documents that have child docs matching the query.
            </summary>
            <typeparam name="K">Type of the child</typeparam>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Limit(System.Nullable{System.Int32})">
            <summary>
            A limit filter limits the number of documents (per shard) to execute on.
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Type(System.String)">
            <summary>
            Filters documents matching the provided document / mapping type. 
            Note, this filter can work even when the _type field is not indexed 
            (using the _uid field).
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.MatchAll">
            <summary>
            A filter that matches on all documents.
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.NumericRange(System.Action{Nest.NumericRangeFilterDescriptor{`0}})">
            <summary>
            Filters documents with fields that have values within a certain numeric range. 
            Similar to range filter, except that it works only with numeric values, 
            and the filter execution works differently.
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Range(System.Action{Nest.RangeFilterDescriptor{`0}})">
            <summary>
            Filters documents with fields that have terms within a certain range. 
            Similar to range query, except that it acts as a filter. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Script(System.Action{Nest.ScriptFilterDescriptor})">
            <summary>
            A filter allowing to define scripts as filters. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Prefix(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
            <summary>
            Filters documents that have fields containing terms with a specified prefix 
            (not analyzed). Similar to phrase query, except that it acts as a filter. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Prefix(System.String,System.String)">
            <summary>
            Filters documents that have fields containing terms with a specified prefix 
            (not analyzed). Similar to phrase query, except that it acts as a filter. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Term(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
            <summary>
            Filters documents that have fields that contain a term (not analyzed). 
            Similar to term query, except that it acts as a filter
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Term(System.String,System.String)">
            <summary>
            Filters documents that have fields that contain a term (not analyzed).
            Similar to term query, except that it acts as a filter
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Terms(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IEnumerable{System.String},System.Nullable{Nest.TermsExecution})">
            <summary>
            Filters documents that have fields that match any of the provided terms (not analyzed). 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Terms(System.String,System.Collections.Generic.IEnumerable{System.String},System.Nullable{Nest.TermsExecution})">
            <summary>
            Filters documents that have fields that match any of the provided terms (not analyzed). 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.And(System.Func{Nest.FilterDescriptor{`0},Nest.BaseFilter}[])">
            <summary>
            A filter that matches documents using AND boolean operator on other queries. 
            This filter is more performant then bool filter. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.And(Nest.BaseFilter[])">
            <summary>
            A filter that matches documents using AND boolean operator on other queries. 
            This filter is more performant then bool filter. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Or(System.Func{Nest.FilterDescriptor{`0},Nest.BaseFilter}[])">
            <summary>
            A filter that matches documents using OR boolean operator on other queries. 
            This filter is more performant then bool filter
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Or(Nest.BaseFilter[])">
            <summary>
            A filter that matches documents using OR boolean operator on other queries. 
            This filter is more performant then bool filter
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Not(System.Func{Nest.FilterDescriptor{`0},Nest.BaseFilter})">
            <summary>
            A filter that filters out matched documents using a query. 
            This filter is more performant then bool filter. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Bool(System.Action{Nest.BoolFilterDescriptor{`0}})">
            <summary>
            
            A filter that matches documents matching boolean combinations of other queries.
            Similar in concept to Boolean query, except that the clauses are other filters. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Query(System.Func{Nest.QueryDescriptor{`0},Nest.BaseQuery})">
            <summary>
            Wraps any query to be used as a filter. 
            </summary>
        </member>
        <member name="M:Nest.FilterDescriptor`1.Nested(System.Action{Nest.NestedFilterDescriptor{`0}})">
            <summary>
             A nested filter, works in a similar fashion to the nested query, except used as a filter.
             It follows exactly the same structure, but also allows to cache the results 
             (set _cache to true), and have it named (set the _name value). 
            </summary>
            <param name="selector"></param>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.FromExclusive">
            <summary>
            Forces the 'From()' to be exclusive (which is inclusive by default).
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.ToExclusive">
            <summary>
            Forces the 'To()' to be exclusive (which is inclusive by default).
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.To(System.Nullable{System.Int32})">
            <summary>
            The upper bound. Defaults to unbounded.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.From(System.Nullable{System.Int32})">
            <summary>
            The lower bound. Defaults to start from the first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.Greater(System.Nullable{System.Int32})">
            <summary>
            Same as setting from and include_lower to false.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.GreaterOrEquals(System.Nullable{System.Int32})">
            <summary>
            Same as setting from and include_lower to true.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.Lower(System.Nullable{System.Int32})">
            <summary>
            Same as setting to and include_upper to false.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.LowerOrEquals(System.Nullable{System.Int32})">
            <summary>
            Same as setting to and include_upper to true.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.To(System.Nullable{System.Double})">
            <summary>
            The upper bound. Defaults to unbounded.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.From(System.Nullable{System.Double})">
            <summary>
            The lower bound. Defaults to start from the first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.Greater(System.Nullable{System.Double})">
            <summary>
            Same as setting from and include_lower to false.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.GreaterOrEquals(System.Nullable{System.Double})">
            <summary>
            Same as setting from and include_lower to true.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.Lower(System.Nullable{System.Double})">
            <summary>
            Same as setting to and include_upper to false.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.LowerOrEquals(System.Nullable{System.Double})">
            <summary>
            Same as setting to and include_upper to true.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.To(System.String)">
            <summary>
            The upper bound. Defaults to unbounded.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.From(System.String)">
            <summary>
            The lower bound. Defaults to start from the first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.Greater(System.String)">
            <summary>
            Same as setting from and include_lower to false.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.GreaterOrEquals(System.String)">
            <summary>
            Same as setting from and include_lower to true.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.Lower(System.String)">
            <summary>
            Same as setting to and include_upper to false.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.LowerOrEquals(System.String)">
            <summary>
            Same as setting to and include_upper to true.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.To(System.Nullable{System.DateTime},System.String)">
            <summary>
            The upper bound. Defaults to unbounded.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.From(System.Nullable{System.DateTime},System.String)">
            <summary>
            The lower bound. Defaults to start from the first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.Greater(System.Nullable{System.DateTime},System.String)">
            <summary>
            Same as setting from and include_lower to false.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.GreaterOrEquals(System.Nullable{System.DateTime},System.String)">
            <summary>
            Same as setting from and include_lower to true.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.Lower(System.Nullable{System.DateTime},System.String)">
            <summary>
            Same as setting to and include_upper to false.
            </summary>
        </member>
        <member name="M:Nest.RangeFilterDescriptor`1.LowerOrEquals(System.Nullable{System.DateTime},System.String)">
            <summary>
            Same as setting to and include_upper to true.
            </summary>
        </member>
        <member name="M:Nest.BoolQueryDescriptor`1.MinimumNumberShouldMatch(System.Int32)">
            <summary>
            Specifies a minimum number of the optional BooleanClauses which must be satisfied.
            </summary>
            <param name="minimumShouldMatches"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.BoolQueryDescriptor`1.Must(System.Func{Nest.QueryDescriptor{`0},Nest.BaseQuery}[])">
            <summary>
            The clause(s) that must appear in matching documents
            </summary>
        </member>
        <member name="M:Nest.BoolQueryDescriptor`1.Must(Nest.BaseQuery[])">
            <summary>
            The clause(s) that must appear in matching documents
            </summary>
        </member>
        <member name="M:Nest.BoolQueryDescriptor`1.MustNot(System.Func{Nest.QueryDescriptor{`0},Nest.BaseQuery}[])">
            <summary>
            The clause (query) should appear in the matching document. A boolean query with no must clauses, one or more should clauses must match a document. The minimum number of should clauses to match can be set using minimum_number_should_match parameter.
            </summary>
            <param name="queries"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.BoolQueryDescriptor`1.MustNot(Nest.BaseQuery[])">
            <summary>
            The clause (query) should appear in the matching document. A boolean query with no must clauses, one or more should clauses must match a document. The minimum number of should clauses to match can be set using minimum_number_should_match parameter.
            </summary>
            <param name="queries"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.BoolQueryDescriptor`1.Should(System.Func{Nest.QueryDescriptor{`0},Nest.BaseQuery}[])">
            <summary>
            The clause (query) must not appear in the matching documents. Note that it is not possible to search on documents that only consists of a must_not clauses.
            </summary>
            <param name="queries"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.BoolQueryDescriptor`1.Should(Nest.BaseQuery[])">
            <summary>
            The clause (query) must not appear in the matching documents. Note that it is not possible to search on documents that only consists of a must_not clauses.
            </summary>
            <param name="queries"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.ToExclusive">
            <summary>
            Forces the 'To()' to be exclusive (which is inclusive by default).
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.FromExclusive">
            <summary>
            Forces the 'From()' to be exclusive (which is inclusive by default).
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.To(System.Nullable{System.Int32})">
            <summary>
            The upper bound. Defaults to unbounded.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.From(System.Nullable{System.Int32})">
            <summary>
            The lower bound. Defaults to start from the first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.Greater(System.Nullable{System.Int32})">
            <summary>
            Same as setting from and include_lower to false.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.GreaterOrEquals(System.Nullable{System.Int32})">
            <summary>
            Same as setting from and include_lower to true.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.Lower(System.Nullable{System.Int32})">
            <summary>
            Same as setting to and include_upper to false.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.LowerOrEquals(System.Nullable{System.Int32})">
            <summary>
            Same as setting to and include_upper to true.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.To(System.Nullable{System.Double})">
            <summary>
            The upper bound. Defaults to unbounded.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.From(System.Nullable{System.Double})">
            <summary>
            The lower bound. Defaults to start from the first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.Greater(System.Nullable{System.Double})">
            <summary>
            Same as setting from and include_lower to false.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.GreaterOrEquals(System.Nullable{System.Double})">
            <summary>
            Same as setting from and include_lower to true.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.Lower(System.Nullable{System.Double})">
            <summary>
            Same as setting to and include_upper to false.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.LowerOrEquals(System.Nullable{System.Double})">
            <summary>
            Same as setting to and include_upper to true.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.To(System.String)">
            <summary>
            The upper bound. Defaults to unbounded.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.From(System.String)">
            <summary>
            The lower bound. Defaults to start from the first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.Greater(System.String)">
            <summary>
            Same as setting from and include_lower to false.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.GreaterOrEquals(System.String)">
            <summary>
            Same as setting from and include_lower to true.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.Lower(System.String)">
            <summary>
            Same as setting to and include_upper to false.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.LowerOrEquals(System.String)">
            <summary>
            Same as setting to and include_upper to true.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.To(System.Nullable{System.DateTime},System.String)">
            <summary>
            The upper bound. Defaults to unbounded.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.From(System.Nullable{System.DateTime},System.String)">
            <summary>
            The lower bound. Defaults to start from the first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.Greater(System.Nullable{System.DateTime},System.String)">
            <summary>
            Same as setting from and include_lower to false.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.GreaterOrEquals(System.Nullable{System.DateTime},System.String)">
            <summary>
            Same as setting from and include_lower to true.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.Lower(System.Nullable{System.DateTime},System.String)">
            <summary>
            Same as setting to and include_upper to false.
            </summary>
        </member>
        <member name="M:Nest.RangeQueryDescriptor`1.LowerOrEquals(System.Nullable{System.DateTime},System.String)">
            <summary>
            Same as setting to and include_upper to true.
            </summary>
        </member>
        <member name="T:Nest.TextPhrasePrefixQueryDescriptor`1">
            <summary>
            A Query that matches documents containing a particular sequence of terms.
            It allows for prefix matches on the last term in the text.
            </summary>
            <typeparam name="T">Type of document</typeparam>
        </member>
        <member name="T:Nest.TextPhraseQueryDescriptor`1">
            <summary>
            A Query that matches documents containing a particular sequence of terms. A PhraseQuery is built by QueryParser for input like "new york".
            </summary>
            <typeparam name="T">Type of document</typeparam>
        </member>
        <member name="M:Nest.CustomScoreQueryDescriptor`1.Script(System.String)">
            <summary>
            Scripts are cached for faster execution. If the script has parameters that it needs to take into account, it is preferable to use the same script, and provide parameters to it:
            </summary>
            <param name="script"></param>
            <returns></returns>
        </member>
        <member name="M:Nest.DSL.Descriptors.SortDescriptor`1.ToggleSort(System.Boolean)">
            <summary>
            Pass true to sort ascending false to sort descending
            </summary>
        </member>
        <member name="M:Nest.DSL.Descriptors.SortGeoDistanceDescriptor`1.ToggleSort(System.Boolean)">
            <summary>
            Pass true to sort ascending false to sort descending
            </summary>
        </member>
        <member name="M:Nest.DSL.Descriptors.SortScriptDescriptor`1.MissingValue(System.String)">
            <summary>
            Value to sort on when the orginal value for the field is missing
            </summary>
        </member>
        <member name="M:Nest.DSL.Descriptors.SortScriptDescriptor`1.ToggleSort(System.Boolean)">
            <summary>
            Pass true to sort ascending false to sort descending
            </summary>
        </member>
        <member name="T:Nest.Lang">
            <summary>
            Scripting Language.
            </summary>
        </member>
        <member name="F:Nest.Lang.mvel">
            <summary>
            Language Mvel.
            </summary>
        </member>
        <member name="F:Nest.Lang.js">
            <summary>
            Language Java Script.
            </summary>
        </member>
        <member name="F:Nest.Lang.groovy">
            <summary>
            Language Groovy
            </summary>
        </member>
        <member name="F:Nest.Lang.python">
            <summary>
            Language Python
            </summary>
        </member>
        <member name="F:Nest.Lang.native">
            <summary>
            Native
            </summary>
        </member>
        <member name="F:Nest.DateRounding.Floor">
            <summary>
            (the default), rounds to the lowest whole unit of this field.
            </summary>
        </member>
        <member name="F:Nest.DateRounding.Ceiling">
            <summary>
            Rounds to the highest whole unit of this field.
            </summary>
        </member>
        <member name="F:Nest.DateRounding.Half_Floor">
            <summary>
             Round to the nearest whole unit of this field. If the given millisecond value is closer to the floor or is exactly halfway, this function behaves like floor. If the millisecond value is closer to the ceiling, this function behaves like ceiling.
            </summary>
        </member>
        <member name="F:Nest.DateRounding.Half_Ceiling">
            <summary>
            Round to the nearest whole unit of this field. If the given millisecond value is closer to the floor, this function behaves like floor. If the millisecond value is closer to the ceiling or is exactly halfway, this function behaves like ceiling.
            </summary>
        </member>
        <member name="F:Nest.DateRounding.Half_Even">
            <summary>
            Round to the nearest whole unit of this field. If the given millisecond value is closer to the floor, this function behaves like floor. If the millisecond value is closer to the ceiling, this function behaves like ceiling. If the millisecond value is exactly halfway between the floor and ceiling, the ceiling is chosen over the floor only if it makes this field’s value even.
            </summary>
        </member>
        <member name="T:Nest.ScriptFilterDescriptor">
            <summary>
            A filter allowing to define scripts as filters.
            Ex: "doc['num1'].value > 1"
            </summary>
        </member>
        <member name="M:Nest.ScriptFilterDescriptor.Script(System.String)">
            <summary>
            Filter script.
            </summary>
            <param name="script">script</param>
            <returns>this</returns>
        </member>
        <member name="M:Nest.ScriptFilterDescriptor.Params(System.Func{Nest.FluentDictionary{System.String,System.Object},Nest.FluentDictionary{System.String,System.Object}})">
            <summary>
            Scripts are compiled and cached for faster execution.
            If the same script can be used, just with different parameters provider,
            it is preferable to use the ability to pass parameters to the script itself.
            Ex:
            	Script: "doc['num1'].value > param1"
            	param: "param1" = 5
            </summary>
            <param name="paramDictionary">param</param>
            <returns>this</returns>
        </member>
        <member name="M:Nest.ScriptFilterDescriptor.Lang(Nest.Lang)">
            <summary>
            Language of script.
            </summary>
            <param name="lang">language</param>
            <returns>this</returns>
        </member>
        <member name="T:Nest.NumericRangeFilterDescriptor`1">
            <summary>
            Filters documents with fields that have values within a certain numeric range. Similar to range filter, except that it works only with numeric values
            </summary>
            <typeparam name="T">Type of document</typeparam>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.FromExclusive">
            <summary>
            Forces the 'From()' to be exclusive (which is inclusive by default).
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.ToExclusive">
            <summary>
            Forces the 'To()' to be exclusive (which is inclusive by default).
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.To(System.Nullable{System.Int32})">
            <summary>
            The upper bound. Defaults to unbounded.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.From(System.Nullable{System.Int32})">
            <summary>
            The lower bound. Defaults to start from the first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.Greater(System.Nullable{System.Int32})">
            <summary>
            Same as setting from and include_lower to false.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.GreaterOrEquals(System.Nullable{System.Int32})">
            <summary>
            Same as setting from and include_lower to true.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.Lower(System.Nullable{System.Int32})">
            <summary>
            Same as setting to and include_upper to false.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.LowerOrEquals(System.Nullable{System.Int32})">
            <summary>
            Same as setting to and include_upper to true.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.To(System.Nullable{System.Double})">
            <summary>
            The upper bound. Defaults to unbounded.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.From(System.Nullable{System.Double})">
            <summary>
            The lower bound. Defaults to start from the first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.Greater(System.Nullable{System.Double})">
            <summary>
            Same as setting from and include_lower to false.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.GreaterOrEquals(System.Nullable{System.Double})">
            <summary>
            Same as setting from and include_lower to true.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.Lower(System.Nullable{System.Double})">
            <summary>
            Same as setting to and include_upper to false.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.LowerOrEquals(System.Nullable{System.Double})">
            <summary>
            Same as setting to and include_upper to true.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.To(System.String)">
            <summary>
            The upper bound. Defaults to unbounded.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.From(System.String)">
            <summary>
            The lower bound. Defaults to start from the first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.Greater(System.String)">
            <summary>
            Same as setting from and include_lower to false.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.GreaterOrEquals(System.String)">
            <summary>
            Same as setting from and include_lower to true.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.Lower(System.String)">
            <summary>
            Same as setting to and include_upper to false.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.LowerOrEquals(System.String)">
            <summary>
            Same as setting to and include_upper to true.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.To(System.Nullable{System.DateTime},System.String)">
            <summary>
            The upper bound. Defaults to unbounded.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.From(System.Nullable{System.DateTime},System.String)">
            <summary>
            The lower bound. Defaults to start from the first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.Greater(System.Nullable{System.DateTime},System.String)">
            <summary>
            Same as setting from and include_lower to false.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.GreaterOrEquals(System.Nullable{System.DateTime},System.String)">
            <summary>
            Same as setting from and include_lower to true.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.Lower(System.Nullable{System.DateTime},System.String)">
            <summary>
            Same as setting to and include_upper to false.
            </summary>
        </member>
        <member name="M:Nest.NumericRangeFilterDescriptor`1.LowerOrEquals(System.Nullable{System.DateTime},System.String)">
            <summary>
            Same as setting to and include_upper to true.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Indices(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            The indices to execute the search on. Defaults to the default index
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Index(System.String)">
            <summary>
            The index to execute the search on. Defaults to the default index
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Types(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            The types to execute the search on. Defaults to the inferred typename of T 
            unless T is dynamic then a type (or AllTypes()) MUST be specified.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Types(System.String[])">
            <summary>
            The types to execute the search on. Defaults to the inferred typename of T 
            unless T is dynamic then a type (or AllTypes()) MUST be specified.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Types(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            The types to execute the search on. Defaults to the inferred typename of T 
            unless T is dynamic then a type (or AllTypes()) MUST be specified.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Types(System.Type[])">
            <summary>
            The types to execute the search on. Defaults to the inferred typename of T 
            unless T is dynamic then a type (or AllTypes()) MUST be specified.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Type(System.String)">
            <summary>
            The type to execute the search on. Defaults to the inferred typename of T 
            unless T is dynamic then a type (or AllTypes()) MUST be specified.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Type(System.Type)">
            <summary>
            The type to execute the search on. Defaults to the inferred typename of T 
            unless T is dynamic then a type (or AllTypes()) MUST be specified.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.AllIndices">
            <summary>
            Execute search over all indices
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.AllTypes">
            <summary>
            Execute search over all types
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Routing(System.String)">
            <summary>
            When executing a search, it will be broadcasted to all the index/indices shards (round robin between replicas).
            Which shards will be searched on can be controlled by providing the routing parameter.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.SearchType(Nest.SearchType)">
            <summary>
            controls how the distributed search behaves. http://www.elasticsearch.org/guide/reference/api/search/search-type.html
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Scroll(System.String)">
            <summary>
            A search request can be scrolled by specifying the scroll parameter. The scroll parameter is a time value parameter (for example: scroll=5m), indicating for how long the nodes that participate in the search will maintain relevant resources in order to continue and support it. This is very similar in its idea to opening a cursor against a database.
            </summary>
            <param name="scrollTime">The scroll parameter is a time value parameter (for example: scroll=5m)</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nest.SearchDescriptor`1.Strict(System.Boolean)" -->
        <member name="M:Nest.SearchDescriptor`1.Size(System.Int32)">
            <summary>
            The number of hits to return. Defaults to 10. When using scroll search type 
            size is actually multiplied by the number of shards!
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Take(System.Int32)">
            <summary>
            The number of hits to return. Defaults to 10.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.From(System.Int32)">
            <summary>
            The starting from index of the hits to return. Defaults to 0.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Skip(System.Int32)">
            <summary>
            The starting from index of the hits to return. Defaults to 0.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Timeout(System.String)">
            <summary>
            A search timeout, bounding the search request to be executed within the 
            specified time value and bail with the hits accumulated up
            to that point when expired. Defaults to no timeout.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Explain(System.Boolean)">
            <summary>
            Enables explanation for each hit on how its score was computed. 
            (Use .DocumentsWithMetaData on the return results)
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Version(System.Boolean)">
            <summary>
            Returns a version for each search hit. (Use .DocumentsWithMetaData on the return results)
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.TrackScores(System.Boolean)">
            <summary>
            Make sure we keep calculating score even if we are sorting on a field.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.MinScore(System.Double)">
            <summary>
            Allows to filter out documents based on a minimum score:
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Preference(System.String)">
            <summary>
            <para>
            Controls a preference of which shard replicas to execute the search request on. 
            By default, the operation is randomized between the each shard replicas.
            </para>
            <para>
            Custom (string) value: A custom value will be used to guarantee that the same shards
            will be used for the same custom value. This can help with “jumping values” 
            when hitting different shards in different refresh states. 
            A sample value can be something like the web session id, or the user name.
            </para>
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.ExecuteOnPrimary">
            <summary>
            <para>
            Controls a preference of which shard replicas to execute the search request on. 
            By default, the operation is randomized between the each shard replicas.
            </para>
            <para>
            The operation will go and be executed only on the primary shards.
            </para>
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.ExecuteOnLocalShard">
            <summary>
            <para>
            Controls a preference of which shard replicas to execute the search request on. 
            By default, the operation is randomized between the each shard replicas.
            </para>
            <para>
            The operation will prefer to be executed on a local allocated shard is possible.
            </para>
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.ExecuteOnNode(System.String)">
            <summary>
            <para>
            Controls a preference of which shard replicas to execute the search request on. 
            By default, the operation is randomized between the each shard replicas.
            </para>
            <para>
            Restricts the search to execute only on a node with the provided node id
            </para>
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.IndicesBoost(System.Func{Nest.FluentDictionary{System.String,System.Double},Nest.FluentDictionary{System.String,System.Double}})">
            <summary>
            Allows to configure different boost level per index when searching across 
            more than one indices. This is very handy when hits coming from one index
            matter more than hits coming from another index (think social graph where each user has an index).
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Fields(System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Allows to selectively load specific fields for each document 
            represented by a search hit. Defaults to load the internal _source field.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Fields(System.String[])">
            <summary>
            Allows to selectively load specific fields for each document 
            represented by a search hit. Defaults to load the internal _source field.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.SortAscending(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            <para>Allows to add one or more sort on specific fields. Each sort can be reversed as well.
            The sort is defined on a per field level, with special field name for _score to sort by score.
            </para>
            <para>
            Sort ascending.
            </para>
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.SortDescending(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            <para>Allows to add one or more sort on specific fields. Each sort can be reversed as well.
            The sort is defined on a per field level, with special field name for _score to sort by score.
            </para>
            <para>
            Sort descending.
            </para>
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.SortAscending(System.String)">
            <summary>
            <para>Allows to add one or more sort on specific fields. Each sort can be reversed as well.
            The sort is defined on a per field level, with special field name for _score to sort by score.
            </para>
            <para>
            Sort ascending.
            </para>
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.SortDescending(System.String)">
            <summary>
            <para>Allows to add one or more sort on specific fields. Each sort can be reversed as well.
            The sort is defined on a per field level, with special field name for _score to sort by score.
            </para>
            <para>
            Sort descending.
            </para>
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Sort(System.Func{Nest.DSL.Descriptors.SortDescriptor{`0},Nest.DSL.Descriptors.SortDescriptor{`0}})">
            <summary>
            <para>Sort() allows you to fully describe your sort unlike the SortAscending and SortDescending aliases.
            </para>
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.SortGeoDistance(System.Func{Nest.DSL.Descriptors.SortGeoDistanceDescriptor{`0},Nest.DSL.Descriptors.SortGeoDistanceDescriptor{`0}})">
            <summary>
            <para>SortGeoDistance() allows you to sort by a distance from a geo point.
            </para>
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.SortScript(System.Func{Nest.DSL.Descriptors.SortScriptDescriptor{`0},Nest.DSL.Descriptors.SortScriptDescriptor{`0}})">
            <summary>
            <para>SortScript() allows you to sort by a distance from a geo point.
            </para>
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetTerm(System.String,System.Func{Nest.TermFacetDescriptor{`0},Nest.TermFacetDescriptor{`0}})">
            <summary>
            Allow to specify field facets that return the N most frequent terms.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetTerm(System.Func{Nest.TermFacetDescriptor{`0},Nest.TermFacetDescriptor{`0}},System.String)">
            <summary>
            Allow to specify field facets that return the N most frequent terms.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetRange``1(System.String,System.Func{Nest.RangeFacetDescriptor{`0,``0},Nest.RangeFacetDescriptor{`0,``0}})">
            <summary>
            range facet allow to specify a set of ranges and get both the number of docs (count) 
            that fall within each range, and aggregated data either based on the field, or using another field
            </summary>
            <typeparam name="K">struct, (int, double, string, DateTime)</typeparam>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetRange``1(System.Func{Nest.RangeFacetDescriptor{`0,``0},Nest.RangeFacetDescriptor{`0,``0}},System.String)">
            <summary>
            range facet allow to specify a set of ranges and get both the number of docs (count) 
            that fall within each range, and aggregated data either based on the field, or using another field
            </summary>
            <typeparam name="K">struct, (int, double, string, DateTime)</typeparam>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetHistogram(System.String,System.Func{Nest.HistogramFacetDescriptor{`0},Nest.HistogramFacetDescriptor{`0}})">
            <summary>
            The histogram facet works with numeric data by building a histogram across intervals 
            of the field values. Each value is “rounded” into an interval (or placed in a bucket), 
            and statistics are provided per interval/bucket (count and total). 
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetHistogram(System.Func{Nest.HistogramFacetDescriptor{`0},Nest.HistogramFacetDescriptor{`0}},System.String)">
            <summary>
            The histogram facet works with numeric data by building a histogram across intervals 
            of the field values. Each value is “rounded” into an interval (or placed in a bucket), 
            and statistics are provided per interval/bucket (count and total). 
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetDateHistogram(System.String,System.Func{Nest.DateHistogramFacetDescriptor{`0},Nest.DateHistogramFacetDescriptor{`0}})">
            <summary>
            A specific histogram facet that can work with date field types enhancing it over the regular histogram facet.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetDateHistogram(System.Func{Nest.DateHistogramFacetDescriptor{`0},Nest.DateHistogramFacetDescriptor{`0}},System.String)">
            <summary>
            A specific histogram facet that can work with date field types enhancing it over the regular histogram facet.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetStatistical(System.String,System.Func{Nest.StatisticalFacetDescriptor{`0},Nest.StatisticalFacetDescriptor{`0}})">
            <summary>
            Statistical facet allows to compute statistical data on a numeric fields. 
            The statistical data include count, total, sum of squares, 
            mean (average), minimum, maximum, variance, and standard deviation. 
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetStatistical(System.Func{Nest.StatisticalFacetDescriptor{`0},Nest.StatisticalFacetDescriptor{`0}},System.String)">
            <summary>
            Statistical facet allows to compute statistical data on a numeric fields. 
            The statistical data include count, total, sum of squares, 
            mean (average), minimum, maximum, variance, and standard deviation. 
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetTermsStats(System.String,System.Func{Nest.TermsStatsFacetDescriptor{`0},Nest.TermsStatsFacetDescriptor{`0}})">
            <summary>
            The terms_stats facet combines both the terms and statistical allowing 
            to compute stats computed on a field, per term value driven by another field.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetTermsStats(System.Func{Nest.TermsStatsFacetDescriptor{`0},Nest.TermsStatsFacetDescriptor{`0}},System.String)">
            <summary>
            The terms_stats facet combines both the terms and statistical allowing 
            to compute stats computed on a field, per term value driven by another field.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetGeoDistance(System.String,System.Func{Nest.GeoDistanceFacetDescriptor{`0},Nest.GeoDistanceFacetDescriptor{`0}})">
            <summary>
            The geo_distance facet is a facet providing information for ranges of distances
            from a provided geo_point including count of the number of hits that fall 
            within each range, and aggregation information (like total).
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetGeoDistance(System.Func{Nest.GeoDistanceFacetDescriptor{`0},Nest.GeoDistanceFacetDescriptor{`0}},System.String)">
            <summary>
            The geo_distance facet is a facet providing information for ranges of distances
            from a provided geo_point including count of the number of hits that fall 
            within each range, and aggregation information (like total).
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetQuery(System.String,System.Func{Nest.QueryDescriptor{`0},Nest.BaseQuery},System.Nullable{System.Boolean})">
            <summary>
            A facet query allows to return a count of the hits matching 
            the facet query. The query itself can be expressed using the Query DSL.
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FacetFilter(System.String,System.Func{Nest.FilterDescriptor{`0},Nest.BaseFilter})">
            <summary>
            A filter facet (not to be confused with a facet filter) allows you to return a count of the h
            its matching the filter. The filter itself can be expressed using the Query DSL.
            Note, filter facet filters are faster than query facet when using native filters (non query wrapper ones).
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Query(System.Func{Nest.QueryDescriptor{`0},Nest.BaseQuery})">
            <summary>
            Describe the query to perform using a query descriptor lambda
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Query(Nest.BaseQuery)">
            <summary>
            Describe the query to perform using the static Query class
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.QueryString(System.String)">
            <summary>
            Shortcut to .Query(q=>q.QueryString(qs=>qs.Query("string"))
            Does a match_all if the userInput string is null or empty;
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.QueryRaw(System.String)">
            <summary>
            Describe the query to perform as a raw json string
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Filter(System.Func{Nest.FilterDescriptor{`0},Nest.BaseFilter})">
            <summary>
            Filter search using a filter descriptor lambda
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Filter(Nest.BaseFilter)">
            <summary>
            Filter search
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.FilterRaw(System.String)">
            <summary>
            Filter search using a raw json string
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.Highlight(System.Action{Nest.HighlightDescriptor{`0}})">
            <summary>
            Allow to highlight search results on one or more fields. The implementation uses the either lucene fast-vector-highlighter or highlighter. 
            </summary>
        </member>
        <member name="M:Nest.SearchDescriptor`1.MatchAll">
            <summary>
            Shorthand for a match_all query without having to specify .Query(q=>q.MatchAll())
            </summary>
        </member>
        <member name="P:Nest.SearchDescriptor`1._Strict">
            <summary>
            Whiter conditionless queries are allowed or not
            </summary>
        </member>
        <member name="F:Nest.ConnectionErrorType.Uncaught">
            <summary>
            The error was due to an uncaught exception in the client code
            </summary>
        </member>
        <member name="F:Nest.ConnectionErrorType.Server">
            <summary>
            The error was due to an error thrown by Elasticsearch
            </summary>
        </member>
        <member name="M:Nest.ConnectionSettings.#ctor(System.Uri)">
            <summary>
            Instantiate a connectionsettings object to tell the client where and how to connect to elasticsearch
            </summary>
            <param name="uri">A Uri to describe the elasticsearch endpoint</param>
        </member>
        <member name="M:Nest.ConnectionSettings.#ctor(System.Uri,System.Int32)">
            <summary>
            Instantiate a connectionsettings object to tell the client where and how to connect to elasticsearch
            </summary>
            <param name="uri">A Uri to describe the elasticsearch endpoint</param>
            <param name="timeout">time out in milliseconds</param>
        </member>
        <member name="M:Nest.ConnectionSettings.#ctor(System.Uri,System.Int32,System.String,System.String,System.String)">
            <summary>
            Instantiate a connectionsettings object to tell the client where and how to connect to elasticsearch
            using a proxy
            </summary>
            <param name="uri">A Uri to describe the elasticsearch endpoint</param>
            <param name="timeout">time out in milliseconds</param>
            <param name="proxyAddress">proxy address</param>
            <param name="username">proxy username</param>
            <param name="password">proxy password</param>
        </member>
        <member name="M:Nest.ConnectionSettings.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a connectionsettings object to tell the client where and how to connect to elasticsearch
            </summary>
            <param name="host">host (sans http(s)://), use the Uri constructor overload for more control</param>
            <param name="port">port of the host (elasticsearch defaults on 9200)</param>
        </member>
        <member name="M:Nest.ConnectionSettings.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Instantiate a connectionsettings object to tell the client where and how to connect to elasticsearch
            </summary>
            <param name="host">host (sans http(s)://), use the Uri constructor overload for more control</param>
            <param name="port">port of the host (elasticsearch defaults on 9200)</param>
            <param name="timeout">time out in milliseconds</param>
        </member>
        <member name="M:Nest.ConnectionSettings.#ctor(System.String,System.Int32,System.Int32,System.String,System.String,System.String)">
            <summary>
            Instantiate a connectionsettings object to tell the client where and how to connect to elasticsearch
            </summary>
            <param name="host">host (sans http(s)://), use the Uri constructor overload for more control</param>
            <param name="port">port of the host (elasticsearch defaults on 9200)</param>
            <param name="timeout">time out in milliseconds</param>
            <param name="proxyAddress">proxy address</param>
            <param name="username">proxy username</param>
            <param name="password">proxy password</param>
        </member>
        <member name="M:Nest.ConnectionSettings.SetDefaultIndex(System.String)">
            <summary>
            Index to default to when no index is specified.
            </summary>
            <param name="defaultIndex">When null/empty/not set might throw NRE later on
            when not specifying index explicitly while indexing.
            </param>
            <returns></returns>
        </member>
        <member name="M:Nest.ConnectionSettings.SetMaximumAsyncConnections(System.Int32)">
            <summary>
            Semaphore asynchronous connections automatically by giving
            it a maximum concurrent connections. Great to prevent 
            out of memory exceptions
            </summary>
            <param name="maximum">defaults to 20</param>
            <returns></returns>
        </member>
        <member name="M:Nest.ConnectionSettings.SetTimeout(System.Int32)">
            <summary>
            Timeout in milliseconds when the .NET webrquest should abort the request, note that you can set this to a high value here,
            and specify the timeout in various calls on Elasticsearch's side.
            </summary>
            <param name="timeout">time out in milliseconds</param>
        </member>
        <member name="P:Nest.ElasticPropertyAttribute.NumericType">
            <summary>
            Defaults to float so be sure to set this correctly!
            </summary>
        </member>
        <member name="P:Nest.ElasticPropertyAttribute.DateFormat">
            <summary>
            http://www.elasticsearch.org/guide/reference/mapping/date-format.html
            </summary>
        </member>
        <member name="T:Nest.ElasticMap">
            <summary>
            Static helper to help create resusable RootObjectMappings
            </summary>
        </member>
        <member name="T:Nest.GenericMapping">
            <summary>
            Sometimes you need a generic type mapping, i.e when using dynamic templates 
            in order to specify "{dynamic_template}" the type, or if you have some plugin that exposes a new type.
            </summary>
        </member>
        <member name="P:Nest.GenericMapping.IndexName">
            <summary>
            The name of the field that will be stored in the index. Defaults to the property/field name.
            </summary>
        </member>
        <member name="P:Nest.IndexParameters.Timeout">
            <summary>
            string because you can pass 5m, or 1h to ES
            </summary>
        </member>
        <member name="P:Nest.QueryResponse`1.ScrollId">
            <summary>
            Only set when search type = scan and scroll specified
            </summary>
        </member>
        <member name="T:Nest.CustomAnalyzer">
            <summary>
            An analyzer of type custom that allows to combine a Tokenizer with zero or more Token Filters, and zero or more Char Filters. 
            <para>The custom analyzer accepts a logical/registered name of the tokenizer to use, and a list of logical/registered names of token filters.</para>
            </summary>
        </member>
        <member name="T:Nest.IndexSettings">
            <summary>
            Writing these uses a custom converter that ignores the json props
            </summary>
        </member>
        <member name="T:Nest.SnowballAnalyzer">
            <summary>
            An analyzer of type snowball that uses the standard tokenizer, with standard filter, lowercase filter, stop filter, and snowball filter.
            <para> The Snowball Analyzer is a stemming analyzer from Lucene that is originally based on the snowball project from snowball.tartarus.org.</para>
            </summary>
        </member>
        <member name="T:Nest.ShingleTokenFilter">
            <summary>
            A token filter of type shingle that constructs shingles (token n-grams) from a token stream. 
            <para>In other words, it creates combinations of tokens as a single token. </para>
            </summary>
        </member>
        <member name="P:Nest.ShingleTokenFilter.MinShingleSize">
            <summary>
            The minimum shingle size. Defaults to 2.
            </summary>
        </member>
        <member name="P:Nest.ShingleTokenFilter.MaxShingleSize">
            <summary>
            The maximum shingle size. Defaults to 2.
            </summary>
        </member>
        <member name="P:Nest.ShingleTokenFilter.OutputUnigrams">
            <summary>
            If true the output will contain the input tokens (unigrams) as well as the shingles. Defaults to true.
            </summary>
        </member>
        <member name="P:Nest.ShingleTokenFilter.OutputUnigramsIfNoShingles">
            <summary>
            If output_unigrams is false the output will contain the input tokens (unigrams) if no shingles are available. 
            <para>Note if output_unigrams is set to true this setting has no effect. Defaults to false.</para>
            </summary>
        </member>
        <member name="P:Nest.ShingleTokenFilter.TokenSeparator">
            <summary>
            The string to use when joining adjacent tokens to form a shingle. Defaults to " ".
            </summary>
        </member>
        <member name="T:Nest.Resolvers.ExpressionVisitor">
            <summary>
            This comes from Matt Warren's sample:
            http://blogs.msdn.com/mattwar/archive/2007/07/31/linq-building-an-iqueryable-provider-part-ii.aspx
            </summary>
        </member>
        <member name="T:Nest.Resolvers.Inflector">
            <summary>
            Pluralizes or singularizes words.
            </summary>
        </member>
        <member name="M:Nest.Resolvers.Inflector.#cctor">
            <summary>
            Initializes the <see cref="T:Nest.Resolvers.Inflector"/> class.
            </summary>
        </member>
        <member name="M:Nest.Resolvers.Inflector.AddIrregularRule(System.String,System.String)">
            <summary>
            Adds the irregular rule.
            </summary>
            <param name="singular">The singular.</param>
            <param name="plural">The plural.</param>
        </member>
        <member name="M:Nest.Resolvers.Inflector.AddUnknownCountRule(System.String)">
            <summary>
            Adds the unknown count rule.
            </summary>
            <param name="word">The word.</param>
        </member>
        <member name="M:Nest.Resolvers.Inflector.AddPluralRule(System.String,System.String)">
            <summary>
            Adds the plural rule.
            </summary>
            <param name="rule">The rule.</param>
            <param name="replacement">The replacement.</param>
        </member>
        <member name="M:Nest.Resolvers.Inflector.AddSingularRule(System.String,System.String)">
            <summary>
            Adds the singular rule.
            </summary>
            <param name="rule">The rule.</param>
            <param name="replacement">The replacement.</param>
        </member>
        <member name="M:Nest.Resolvers.Inflector.MakePlural(System.String)">
            <summary>
            Makes the plural.
            </summary>
            <param name="word">The word.</param>
            <returns></returns>
        </member>
        <member name="M:Nest.Resolvers.Inflector.MakeSingular(System.String)">
            <summary>
            Makes the singular.
            </summary>
            <param name="word">The word.</param>
            <returns></returns>
        </member>
        <member name="M:Nest.Resolvers.Inflector.ApplyRules(System.Collections.Generic.IList{Nest.Resolvers.Inflector.InflectorRule},System.String)">
            <summary>
            Applies the rules.
            </summary>
            <param name="rules">The rules.</param>
            <param name="word">The word.</param>
            <returns></returns>
        </member>
        <member name="T:Nest.Resolvers.Inflector.InflectorRule">
            <summary>
            Summary for the InflectorRule class
            </summary>
        </member>
        <member name="M:Nest.Resolvers.Inflector.InflectorRule.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Nest.Resolvers.Inflector.InflectorRule"/> class.
            </summary>
            <param name="regexPattern">The regex pattern.</param>
            <param name="replacementText">The replacement text.</param>
        </member>
        <member name="M:Nest.Resolvers.Inflector.InflectorRule.Apply(System.String)">
            <summary>
            Applies the tule to the specified word.
            </summary>
            <param name="word">The word.</param>
            <returns></returns>
        </member>
        <member name="T:Nest.FieldType">
            <summary>
            Define the type of field content.
            </summary>
        </member>
        <member name="F:Nest.FieldType.none">
            <summary>
            Default. Will be defined by the type of property return.
            </summary>
        </member>
        <member name="F:Nest.FieldType.geo_point">
            <summary>
            Geo based points.
            </summary>
        </member>
        <member name="F:Nest.FieldType.attachment">
            <summary>
            The attachment type allows to index different “attachment” type field (encoded as base64), for example, microsoft office formats, open document formats, ePub, HTML...
            </summary>
        </member>
        <member name="F:Nest.FieldType.ip">
            <summary>
            An ip mapping type allows to store ipv4 addresses in a numeric form allowing to easily sort, and range query it (using ip values).
            </summary>
        </member>
        <member name="F:Nest.FieldType.binary">
            <summary>
            The binary type is a base64 representation of binary data that can be stored in the index.
            </summary>
        </member>
        <member name="F:Nest.FieldType.string_type">
            <summary>
            Text based string type.
            </summary>
        </member>
        <member name="F:Nest.FieldType.integer_type">
            <summary>
            Integer type.
            </summary>
        </member>
        <member name="F:Nest.FieldType.long_type">
            <summary>
            Long type.
            </summary>
        </member>
        <member name="F:Nest.FieldType.float_type">
            <summary>
            Float type.
            </summary>
        </member>
        <member name="F:Nest.FieldType.double_type">
            <summary>
            Double type.
            </summary>
        </member>
        <member name="F:Nest.FieldType.date_type">
            <summary>
            Date type.
            </summary>
        </member>
        <member name="F:Nest.FieldType.boolean_type">
            <summary>
            Boolean type.
            </summary>
        </member>
        <member name="F:Nest.FieldType.nested">
            <summary>
            Nested type.
            </summary>
        </member>
        <member name="F:Nest.FieldType.object">
            <summary>
            object type, no need to set this manually if its not a value type this will be set.
            Only set this if you need to force a value type to be mapped to an elasticsearch object type.
            </summary>
        </member>
        <member name="M:Nest.Resolvers.Writers.TypeMappingWriter.GetElasticSearchType(Nest.ElasticPropertyAttribute,System.Reflection.PropertyInfo)">
            <summary>
            Get the Elastic Search Field Type Related.
            </summary>
            <param name="att">ElasticPropertyAttribute</param>
            <param name="p">Property Field</param>
            <returns>String with the type name or null if can not be inferres</returns>
        </member>
        <member name="M:Nest.Resolvers.Writers.TypeMappingWriter.GetElasticSearchTypeFromFieldType(System.Nullable{Nest.FieldType})">
            <summary>
            Get the Elastic Search Field from a FieldType.
            </summary>
            <param name="fieldType">FieldType</param>
            <returns>String with the type name or null if can not be inferres</returns>
        </member>
        <member name="M:Nest.Resolvers.Writers.TypeMappingWriter.GetFieldTypeFromType(System.Type)">
            <summary>
            Inferes the FieldType from the type of the property.
            </summary>
            <param name="propertyType">Type of the property</param>
            <returns>FieldType or null if can not be inferred</returns>
        </member>
        <member name="T:Nest.StandardAnalyzer">
            <summary>
            An analyzer of type standard that is built of using Standard Tokenizer, with Standard Token Filter, Lower Case Token Filter, and Stop Token Filter.
            </summary>
        </member>
        <member name="P:Nest.StandardAnalyzer.StopWords">
            <summary>
            A list of stopword to initialize the stop filter with. Defaults to the english stop words.
            </summary>
        </member>
        <member name="P:Nest.StandardAnalyzer.MaxTokenLength">
            <summary>
            The maximum token length. If a token is seen that exceeds this length then it is discarded. Defaults to 255.
            </summary>
        </member>
        <member name="T:Nest.StopTokenFilter">
            <summary>
            A token filter of type stop that removes stop words from token streams.
            </summary>
        </member>
        <member name="T:Nest.WordDelimiterTokenFilter">
            <summary>
            Named word_delimiter, it Splits words into subwords and performs optional transformations on subword groups.
            </summary>
        </member>
    </members>
</doc>
